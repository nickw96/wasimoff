// best practices: https://protobuf.dev/programming-guides/dos-donts/
edition = "2023";

import "google/protobuf/any.proto";


// ---------- identifiers for codecs on the wire ---------- //

// Subprotocol is used to identify the concrete encoding on the wire.
enum Subprotocol {
  UNKNOWN = 0;
  wasimoff_provider_v1_protobuf = 1; // binary messages with Protobuf encoding
  wasimoff_provider_v1_json     = 2; // text messages with JSON encoding
}


// ---------- "topmost" wrapped message format ---------- //

// Envelope is a generic message wrapper with a sequence counter and message type.
// The payload contains a { Request, Response, Event }.
message Envelope {

  // The sequence number is incremented for each message but Request and Event
  // count independently. Responses must always reuse the Request's sequence
  // number so they can be routed to the caller correctly.
  uint64 sequence = 1;

  // The message type indicates the payload contents: { Request, Response, Event }.
  MessageType type = 2;
  enum MessageType { UNKNOWN = 0; Request = 1; Response = 2; Event = 3; }

  // The presence of an error indicates that something went wrong with the call
  // in general (like a server "oops"). Otherwise, the called function should
  // encode specific errors within the payload.
  string error = 3;

  // The payload itself. Needs to be (un)packed with `anypb`.
  google.protobuf.Any payload = 4;

}

// Ping stub, if the transport does not provide them. WebSocket does have its
// own mechanism. On WebTransport, you should use a separate stream to avoid re-
// introducing head-of-line blocking with the other RPC requests.
message Ping {
  enum Direction { Ping = 0; Pong = 1; }
  Direction direction = 1;
}


// ---------- individual message definitions ---------- //

// The Any payload can take literally any message and there is no Protobuf-enforced
// typing between the MessageType and the payload. Therefore you should make sure
// to name the Request and Result pairs absolutely clearly. Avoid using a generic
// response message for different requests, even if their fields are identical.


// ---> execute

// ExecuteWasi runs a webassembly/wasi binary on the Provider
message ExecuteWasiRequest {
  TaskMetadata info = 1; // metadata about this task
  WasiTaskArgs task = 2; // arguments for the WebAssembly module
}
message ExecuteWasiResponse {
  string error = 1; // error leading up to the instantiation
  WasiTaskResult result = 2; // result of the execution
}

// TaskMetadata contains some information about the originating job request.
message TaskMetadata {
  string jobID = 1; // overall job ID
  uint64 index = 3; // index within a job with multiple tasks
  string client = 2; // info about the requesting client
}

// WasiTaskArgs should not be sent as a toplevel message directly and instead
// contains necessary references and execution arguments to instantiate a single
// WebAssembly task on the Provider.
message WasiTaskArgs {
  File binary = 1;
  repeated string args = 2;
  repeated string envs = 3;
  bytes stdin = 4;
  File rootfs = 5;
  repeated string artifacts = 6;
}

// WasiTaskResult is the result of an execution from a WasiTaskArgs. It should
// only be returned if the module was instantiated successfully at all, i.e. any
// errors leading up to that should be returned higher up.
message WasiTaskResult {
  int32 status = 1;
  bytes stdout = 2;
  bytes stderr = 3;
  File artifacts = 4;
}


// ---> filesystem

// File is a file reference with optional mime-type. The ref could be a plain
// filename, a prefixed hash digest or a URL to fetch from. When stored, a hash
// digest should be computed to have a stable identifier.
message File {
  string ref = 1; // filename, encoded digest or URL
  string media = 2; // media type in MIME notation
  bytes blob = 3; // the actual file contents
}

// FileListing asks for a listing of all available files on Provider
message FileListingRequest {
  // empty
}
message FileListingResponse {
  repeated string files = 1;
}

// FileProbe checks if a certain file exists on provider
message FileProbeRequest {
  string file = 1;
}
message FileProbeResponse {
  bool ok = 1;
}

// FileUpload pushes a file to the Provider.
message FileUploadRequest {
  File upload = 1;
}
message FileUploadResponse {
  string err = 1;
}

// FileDownload can be sent by the Provider to request a file download.
message FileDownloadRequest {
  string file = 1;
}
message FileDownloadResponse {
  File download = 1;
  string err = 2;
}


// ---> event messages

// Generic is just a generic piece of text for debugging
message GenericEvent {
  string message = 1;
}

// ProviderHello is sent once at the beginning to identify the Provider
message ProviderHello {
  string name = 1; // a logging-friendly name of the provider
  string useragent = 2; // like the navigator.useragent in browser
}

// ProviderResources is information about the available resources in Worker pool
message ProviderResources {
  uint32 concurrency = 1; // maximum possible concurrency (~ number of Workers)
  uint32 tasks = 2; // currently active tasks
}

// ClusterInfo contains information about all connected Providers
message ClusterInfo {
  uint32 providers = 1; // number of currently connected providers
}

// Throughput contains information about overall cluster throughput
message Throughput {
  float overall = 1; // current overall tasks/s throughput
  float yours = 2; // your contribution (identified by name)
}

// CancelTask tells the Provider that it can terminate a task
message CancelTask {
  TaskMetadata info = 1;
  string reason = 2;
}

// FileSystemUpdate notifies the Broker about changed files on the Provider.
message FileSystemUpdate {
  repeated string added = 1;
  repeated string removed = 2;
}


// ---------- client interface ---------- //

// The client interface specifies the messages that the offloading clients
// are expected to send. As a first step, they should just formalize the
// ad-hoc JSON structs that are already used, so at least the Broker can
// use pbjson to parse messages.

// These client requests will arrive on predefined routes, so a normal RPC
// library could be used and no Envelope wrapping is necessary.

// The client upload is a POST request with the binary data as the body, media
// type in the Contet-Type header and the optional friendly name in a query
// parameter. So this message type isn't actually used anywhere yet.
message ClientUploadRequest {
  string name = 1; // friendly name for lookup
  string media = 2; // media type
  bytes body = 3; // binary file contents
}
message ClientUploadResponse {
  string ref = 1; // the hashed ref the file was stored under
  string err = 2; // any errors during file insertion
}

// An offloading request specifies a list of WasiTaskArgs, each possibly
// containing a binary to use, args, envs etc. An optional common parent can
// be given to fill values in tasks. There is no magic in the parameter
// inheritance though: anything in the parent gets entirely replaced by the
// corresponding field in a task spec. At least one task must always be present,
// even if just an empty { } with all parameters inherited from the parent.
message OffloadWasiJobRequest {
  WasiTaskArgs parent = 1; // inherit common task parameters
  repeated WasiTaskArgs tasks = 2; // list of task arguments
}
message OffloadWasiJobResponse {
  string failure = 1; // the complete job failed
  repeated ExecuteWasiResponse tasks = 2; // list of task results
}
