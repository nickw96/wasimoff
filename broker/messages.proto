// best practices: https://protobuf.dev/programming-guides/dos-donts/
edition = "2023";

import "google/protobuf/any.proto";


// ---------- identifiers for codecs on the wire ---------- //

// Subprotocol is used to identify the concrete encoding on the wire.
enum Subprotocol {
  UNKNOWN = 0;
  wasimoff_provider_v1_protobuf = 1; // binary messages with Protobuf encoding
  wasimoff_provider_v1_json     = 2; // text messages with JSON encoding
}


// ---------- "topmost" wrapped message format ---------- //

// Envelope is a generic message wrapper with a sequence counter and message type.
// The payload contains a { Request, Response, Event }.
message Envelope {

  // The sequence number is incremented for each message but Request and Event
  // count independently. Responses must always reuse the Request's sequence
  // number so they can be routed to the caller correctly.
  uint64 sequence = 1;

  // The message type indicates the payload contents: { Request, Response, Event }.
  MessageType type = 2;
  enum MessageType { UNKNOWN = 0; Request = 1; Response = 2; Event = 3; }

  // The presence of an error indicates that something went wrong with the call
  // in general (like a server "oops"). Otherwise, the called function should
  // encode specific errors within the payload.
  string error = 3;

  // The payload itself. Needs to be (un)packed with `anypb`.
  google.protobuf.Any payload = 4;

}

// Ping stub, if the transport does not provide them. WebSocket does have its
// own mechanism. On WebTransport, you should use a separate stream to avoid re-
// introducing head-of-line blocking with the other RPC requests.
message Ping {
  enum Direction { Ping = 0; Pong = 1; }
  Direction direction = 1;
}


// ---------- individual message definitions ---------- //

// The Any payload can take literally any message and there is no Protobuf-enforced
// typing between the MessageType and the payload. Therefore you should make sure
// to name the Request and Result pairs absolutely clearly. Avoid using a generic
// response message for different requests, even if their fields are identical.


// ---> execute

// TaskMetadata contains some information about the originating task for logging
message TaskMetadata {
  string id = 1; // overall job ID
  string client = 2; // info about the requesting client
  uint64 index = 3; // index within a job with multiple tasks
  bool trace = 4; // request a trace of task execution, TODO
}

// ExecuteWasi runs a webassembly/wasi binary on the Provider
message ExecuteWasiArgs {
  TaskMetadata task = 1;
  File binary = 2;
  repeated string args = 3;
  repeated string envs = 4;
  bytes stdin = 5;
  File rootfs = 6;
  repeated string artifacts = 7;
}
message ExecuteWasiResponse {
  string error = 1;
  int32 status = 2;
  bytes stdout = 3;
  bytes stderr = 4;
  File artifacts = 5;
}


// ---> filesystem

// File is a file reference with optional mime-type and length. The reference
// can be a plain filename, a prefixed hash digest or a URL to fetch from. When
// stored, a hash digest should be computed to have a stable identifier.
message File {
  string ref = 1; // filename, encoded digest or URL
  string content = 2; // content-type in MIME notation
  bytes blob = 3; // the actual file contents
}

// FileListing asks for a listing of all available files on Provider
message FileListingArgs {
  // empty
}
message FileListingResponse {
  repeated string files = 1;
}

// FileProbe checks if a certain file exists on provider
message FileProbeArgs {
  string file = 1;
}
message FileProbeResponse {
  bool ok = 1;
}

// FileUpload pushes a file to the Provider.
message FileUploadArgs {
  File upload = 1;
}
message FileUploadResponse {
  string err = 1;
}

// FileDownload can be sent by the Provider to request a file download.
message FileDownloadArgs {
  string file = 1;
}
message FileDownloadResponse {
  File download = 1;
  string err = 2;
}


// ---> events, sent by Provider

// Generic is just a generic piece of text for debugging
message GenericEvent {
  string message = 1;
}

// ProviderHello is sent once at the beginning to identify the Provider
message ProviderHello {
  string name = 1; // a logging-friendly name of the provider
  string useragent = 2; // like the navigator.useragent in browser
}

// ProviderResources is information about the available resources in Worker pool
message ProviderResources {
  uint32 concurrency = 1; // maximum possible concurrency (~ number of Workers)
  uint32 tasks = 2; // currently active tasks
}

// ClusterInfo contains information about all connected Providers
message ClusterInfo {
  uint32 providers = 1; // number of currently connected providers
}

// Throughput contains information about overall cluster throughput
message Throughput {
  float overall = 1; // current overall tasks/s throughput
  float yours = 2; // your contribution (identified by name)
}


// ---------- client interface ---------- //

// The client interface specifies the messages that the offloading clients
// are expected to send. As a first step, they should just formalize the
// ad-hoc JSON structs that are already used, so at least the Broker can
// use pbjson to parse messages.

// These client requests will arrive on predefined routes, so a normal RPC
// library could be used an no Envelope wrapping is necessary.

// The simplest client upload is a POST request with the raw binary inside
// and metadata in headers but I guess we can also use a message type.
message ClientUploadArgs {
  string name = 1;
  string contentType = 2;
  bytes blob = 3;
}
message ClientUploadResponse {
  string ref = 1;
  string err = 2;
}

// An offloading request specifies a binary to use, optionally some common
// parent parameters and then a list of executions of this binary. There is
// no magic in the parent parameter inheritance: anything in the parent gets
// entirely replaced by the corresponding field in a task specification. Though
// you could specify everything in the common parameters, at least one task
// must be present; even if just an empty { }.
message OffloadWasiJobArgs {
  File binary = 1;
  // bool trace = 2; // TODO
  OffloadWasiTask common = 3;
  repeated OffloadWasiTask tasks = 4;
}
message OffloadWasiJobResponse {
  string error = 1;
  // Trace trace = 2; // TODO
  repeated OffloadWasiTaskResult results = 3;
}

message OffloadWasiTask {
  repeated string args = 1;
  repeated string envs = 2;
  bytes stdin = 3;
  File rootfs = 4;
  repeated string artifacts = 5;
}

message OffloadWasiTaskResult {
  string error = 1;
  int32 status = 2;
  bytes stdout = 3;
  bytes stderr = 4;
  File artifacts = 5;
}
