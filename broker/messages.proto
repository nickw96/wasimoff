// best practices: https://protobuf.dev/programming-guides/dos-donts/
edition = "2023";

import "google/protobuf/any.proto";


// ---------- identifiers for codecs on the wire ---------- //

// Subprotocol is used to identify the concrete encoding on the wire.
enum Subprotocol {
  UNKNOWN = 0;
  wasimoff_provider_v1_protobuf = 1; // binary messages with Protobuf encoding
  wasimoff_provider_v1_json     = 2; // text messages with JSON encoding
}


// ---------- "topmost" wrapped message format ---------- //

// Envelope is a generic message wrapper with a sequence counter and message type.
// The payload contains a { Request, Response, Event }.
message Envelope {

  // The sequence number is incremented for each message but Request and Event
  // count independently. Responses must always reuse the Request's sequence
  // number so they can be routed to the caller correctly.
  uint64 sequence = 1;

  // The message type indicates the payload contents: { Request, Response, Event }.
  MessageType type = 2;
  enum MessageType { UNKNOWN = 0; Request = 1; Response = 2; Event = 3; }

  // The presence of an error indicates that something went wrong with the call
  // in general (like a server "oops"). Otherwise, the called function should
  // encode specific errors within the payload.
  string error = 3;

  // The payload itself. Needs to be (un)packed with `anypb`.
  google.protobuf.Any payload = 4;

}

// Ping stub, if the transport does not provide them. WebSocket does have its
// own mechanism. On WebTransport, you should use a separate stream to avoid re-
// introducing head-of-line blocking with the other RPC requests.
message Ping {
  enum Direction { Ping = 0; Pong = 1; }
  Direction direction = 1;
}


// ---------- individual message definitions ---------- //

// The Any payload can take literally any message and there is no Protobuf-enforced
// typing between the MessageType and the payload. Therefore you should make sure
// to name the Request and Result pairs absolutely clearly. Avoid using a generic
// response message for different requests, even if their fields are identical.

// We aren't using gRPC (yet) but we can codify the expected message pairs anyway.
// This service lists the requests that a Broker can send to the Provider, i.e. the
// Provider (the browser) takes the role of a server here!
service Provider {

  // execute
  rpc ExecuteWasi (ExecuteWasiArgs) returns (ExecuteWasiResult);
  // rpc ExecuteWasm (ExecuteWasmArgs) returns (ExecuteWasmResult); // TODO

  // filesystem
  rpc FileProbe (FileProbeArgs) returns (FileProbeResult);
  rpc FileListing (FileListingArgs) returns (FileListingResult);
  rpc FileUpload (FileUploadArgs) returns (FileUploadResult);

}


// ---> execute

// TaskMetadata contains some information about the originating task for logging
message TaskMetadata {
  string id = 1; // overall job ID
  string client = 2; // info about the requesting client
  uint64 index = 3; // index within a job with multiple tasks
}

// Executable can be either a string reference or the raw binary itself
message Executable {
  oneof binary {
    string reference = 1;
    bytes raw = 2;
  }
}

// ExecuteWasi runs a webassembly/wasi binary on the Provider
message ExecuteWasiArgs {
  TaskMetadata task = 1;
  Executable binary = 2;
  repeated string args = 3;
  repeated string envs = 4;
  bytes stdin = 5;
  repeated string loadfs = 6;
  string datafile = 7;
  bool trace = 8;
}
message ExecuteWasiResult {
  int32 status = 1;
  bytes stdout = 2;
  bytes stderr = 3;
  bytes datafile = 4;
  ExecutionTrace trace = 5;
}
message ExecutionTrace {
  // TODO
}


// ---> filesystem

// FileStat contains metadata about a file for identification in other messages
message FileStat {
  string filename = 1;
  string contenttype = 2;
  uint64 length = 3;
  int64 epoch = 5;
  bytes hash = 4;
}

// FileListing asks for a listing of all available files on Provider
message FileListingArgs {
  // empty
}
message FileListingResult {
  repeated FileStat files = 1;
}

// FileProbe checks if a certain file exists on provider
message FileProbeArgs {
  FileStat stat = 1;
}
message FileProbeResult {
  bool ok = 1;
}

// FileUpload pushes a file to the Provider.
message FileUploadArgs {
  FileStat stat = 1;
  bytes file = 2;
}
message FileUploadResult {
  bool ok = 1;
}


// ---> events, sent by Provider

// Generic is just a generic piece of text for debugging
message GenericEvent {
  string message = 1;
}

// ProviderInfo is sent once at the beginning to identify the Provider
message ProviderInfo {
  string name = 1; // a logging-friendly name of the provider
  string platform = 2;  // like the navigator.platform in browser
  string useragent = 3; // like the navigator.useragent in browser
  ProviderResources pool = 4;
}

// ProviderResources is information about the available resources in Worker pool
message ProviderResources {
  uint32 concurrency = 1; // maximum possible concurrency
  uint32 tasks = 2; // currently active tasks
}

// ClusterInfo contains information about all connected Providers
message ClusterInfo {
  uint32 providers = 1; // number of currently connected providers
}


// ---------- client interface ---------- //

// TODO
