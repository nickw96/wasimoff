// best practices: https://protobuf.dev/programming-guides/dos-donts/
edition = "2023";

import "google/protobuf/any.proto";
import "google/protobuf/timestamp.proto";


// ---------- wrapped message format on the wire ---------- //

// Subprotocol is used to identify the concrete encoding on the wire.
enum Subprotocol {
  UNKNOWN = 0;
  wasimoff_provider_v1_protobuf = 1; // binary messages with Protobuf encoding
  wasimoff_provider_v1_json     = 2; // text messages with JSON encoding
}

// Envelope contains one of [ Request | Response | Event ]. The sequence counter
// counts independently between Request and Event.
message Envelope {
  uint64 sequence = 1;
  oneof message {
    Request   request   = 10;
    Response  response  = 11;
    Event     event     = 12;
  };
}

// EnvelopeAny is an alternative approach with an Any at the top level to reduce
// indirection and pointer allocation in Go. DO NOT USE. This was added for a benchmark.
// TODO: remove
message EnvelopeAny {
  enum MessageType { UNKNOWN = 0; Request = 1; Response = 2; Event = 3; }
  uint64 sequence = 1;
  MessageType type = 2;
  string error = 3;
  google.protobuf.Any payload = 4;
}

// Request is an RPC request with some payload. The sequence number is used
// in responses, so the caller can correctly route the pending response.
message Request {
  oneof request {
    ExecuteWasiArgs executeWasiArgs   = 10;
    ExecuteWasmArgs executeWasmArgs   = 11;
    FileListingArgs fileListingArgs   = 12;
    FileProbeArgs   fileProbeArgs     = 13;
    FileUploadArgs  fileUploadArgs    = 14;
  }
}

// Response is the reply to an RPC request with the same sequence number.
// The presence of an error indicates that something went wrong with the call
// in general (like a server "oops"). Otherwise, the called function may encode
// its own error within the payload.
message Response {
  string error = 1; // nil => ok
  oneof response {
    ExecuteWasiResult executeWasiResult   = 10;
    ExecuteWasmResult executeWasmResult   = 11;
    FileListingResult fileListingResult   = 12;
    FileProbeResult   fileProbeResult     = 13;
    FileUploadResult  fileUploadResult    = 14;
  }
}

// Event is a simple informative message that expects no reply.
message Event {
  oneof event {
    ProviderInfo providerInfo = 10;
    ProviderResources providerResources = 11;
  }
}

// TODO: using google.protobuf.Any is ergonomically simpler because you don't need
// to explicitly list all possible types in the message and at least in Go it's much
// nicer to use when creating objects (oneof leads to a *lot* of nesting). But maybe
// the oneof performance is better in the long run because Any effectively double-
// encodes an arbitrary message as bytes within another message.

// Ping stub, if the transport does not provide them. WebSocket does have its
// own mechanism. On WebTransport, you should use a separate stream to avoid re-
// introducing head-of-line blocking with the other RPC requests; so Ping is
// *not* in the Evelope oneof above.
message Ping {
  enum Direction { Ping = 0; Pong = 1; }
  Direction direction = 1;
  google.protobuf.Timestamp time = 2;
}


// ---------- individual message definitions ---------- //

// we're not using gRPC but we can codify the expected request-response pairs anyway
service Provider {
  // execute
  rpc ExecuteWasi (ExecuteWasiArgs) returns (ExecuteWasiResult);
  rpc ExecuteWasm (ExecuteWasmArgs) returns (ExecuteWasmResult);
  // filesystem
  rpc FileListing (FileListingArgs) returns (FileListingResult);
  rpc FileProbe (FileProbeArgs) returns (FileProbeResult);
  rpc FileUpload (FileUploadArgs) returns (FileUploadResult);
}

// ---> execute

// TaskMetadata contains some information about the originating task for logging
message TaskMetadata {
  string id = 1;
  string client = 2;
  uint64 index = 3; // within a job with multiple tasks
}

// Executable can be either a string reference or the raw binary itself
message Executable {
  oneof binary {
    string reference = 1;
    bytes raw = 2;
  }
}

// ExecuteWasi runs a webassembly/wasi binary on the Provider
message ExecuteWasiArgs {
  TaskMetadata task = 1;
  Executable binary = 2;
  repeated string args = 3;
  repeated string envs = 4;
  bytes stdin = 5;
  repeated string loadfs = 6; // TODO: replace with complete rootfs archive
}
message ExecuteWasiResult {
  // TODO
}

// ExecuteWasm runs a webassembly/plain binary on the Provider
message ExecuteWasmArgs {
  TaskMetadata task = 1;
  Executable binary = 2;
  string method = 3;
  // TODO: how to encode plain parameters?
}
message ExecuteWasmResult {
  // TODO
}


// ---> filesystem

// FileStat contains metadata about a file for identification in other messages
message FileStat {
  string filename = 1;
  string contenttype = 2;
  uint64 length = 3;
  uint64 epoch = 5;
  bytes hash = 4;
}

// FileListing asks for a listing of all available files on Provider
message FileListingArgs {
  // empty
}
message FileListingResult {
  repeated FileStat files = 1;
}

// FileProbe checks if a certain file exists on provider
message FileProbeArgs {
  repeated FileStat files = 1;
}
message FileProbeResult {
  repeated bool ok = 1;
}

// FileUpload pushes a file to the Provider.
// TODO: to be replaced with on-demand client-side fetch
message FileUploadArgs {
  FileStat stat = 1;
  bytes file = 2;
}
message FileUploadResult {
  bool ok = 1;
}


// ---> events, sent by Provider

// ProviderInfo is sent once at the beginning to identify the Provider
message ProviderInfo {
  string name = 1;
  string platform = 2;
  string useragent = 3;
  ProviderResources pool = 4;
}

// ProviderResources is information about the available resources in Worker pool
message ProviderResources {
  uint32 nmax = 1; // maximum available
  uint32 tasks = 2; // currently active
}


// ---------- client interface ---------- //

// TODO
