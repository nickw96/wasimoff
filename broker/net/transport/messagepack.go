package transport

import (
	"bytes"

	"github.com/vmihailenco/msgpack/v5"
)

// Note about MarshalMessagepackJson and UnmarshalMessagepackJson:
// ---------------------------------------------------------------
// The idea was to seamlessly use the Go structs generated by protoc with their `json` annotations
// (which I assumed must exist, since protojson marshals lowercase keys) for msgpack. It turns out
// that protojson does a little more magic. For example, the Message field in an Envelope does not
// have `json` struct annotation, which results in multiple nested uppercased objects different
// from the JSON output.
// An additional hurdle with Messagepack is the handling of Any values. When constructing an outer
// element in Go, you need to pack them with anypb.New(). This serializes the message to bytes. When
// using protojson on such a message, it seems to Unmarshal the value again because the inner values
// are sent as JSON and not an opaque blob. Messagepack can't do that by itself and thus sends raw
// bytes, for which you need a Protobuf implementation *anyway* to unpack the inner values.
// Combined with the fact that none of my protocol benchmarks showed a clear advantage of Messagepack
// over Protobuf, I opted to remove the subprotocol. (It wasn't worse! It just wasn't faster either.)

// MarshalMessagepackJson is like msgpack.Marshal but uses `json` struct tags
func MarshalMessagepackJson(v any) (b []byte, err error) {
	var buf bytes.Buffer
	encoder := msgpack.GetEncoder()
	encoder.Reset(&buf)
	encoder.SetCustomStructTag("json")
	if err = encoder.Encode(v); err == nil {
		b = buf.Bytes()
		msgpack.PutEncoder(encoder)
	}
	return
}

// UnmarshalMessagepackJson is like msgpack.Unmarshal but uses `json` struct tags
func UnmarshalMessagepackJson(b []byte, v any) (err error) {
	decoder := msgpack.GetDecoder()
	decoder.Reset(bytes.NewReader(b))
	decoder.SetCustomStructTag("json")
	if err = decoder.Decode(v); err == nil {
		msgpack.PutDecoder(decoder)
	}
	return
}
