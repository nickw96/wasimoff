// best practices: https://protobuf.dev/programming-guides/dos-donts/

// @generated by protoc-gen-es v2.0.0 with parameter "target=ts,json_types=true"
// @generated from file messages.proto (edition 2023)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Any, AnyJson } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_any } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file messages.proto.
 */
export const file_messages: GenFile = /*@__PURE__*/
  fileDesc("Cg5tZXNzYWdlcy5wcm90byK5AQoIRW52ZWxvcGUSEAoIc2VxdWVuY2UYASABKAQSIwoEdHlwZRgCIAEoDjIVLkVudmVsb3BlLk1lc3NhZ2VUeXBlEg0KBWVycm9yGAMgASgJEiUKB3BheWxvYWQYBCABKAsyFC5nb29nbGUucHJvdG9idWYuQW55IkAKC01lc3NhZ2VUeXBlEgsKB1VOS05PV04QABILCgdSZXF1ZXN0EAESDAoIUmVzcG9uc2UQAhIJCgVFdmVudBADIksKBFBpbmcSIgoJZGlyZWN0aW9uGAEgASgOMg8uUGluZy5EaXJlY3Rpb24iHwoJRGlyZWN0aW9uEggKBFBpbmcQABIICgRQb25nEAEiSAoMVGFza01ldGFkYXRhEgoKAmlkGAEgASgJEg4KBmNsaWVudBgCIAEoCRINCgVpbmRleBgDIAEoBBINCgV0cmFjZRgEIAEoCCKaAQoPRXhlY3V0ZVdhc2lBcmdzEhsKBHRhc2sYASABKAsyDS5UYXNrTWV0YWRhdGESFQoGYmluYXJ5GAIgASgLMgUuRmlsZRIMCgRhcmdzGAMgAygJEgwKBGVudnMYBCADKAkSDQoFc3RkaW4YBSABKAwSFQoGcm9vdGZzGAYgASgLMgUuRmlsZRIRCglhcnRpZmFjdHMYByADKAkibgoTRXhlY3V0ZVdhc2lSZXNwb25zZRINCgVlcnJvchgBIAEoCRIOCgZzdGF0dXMYAiABKAUSDgoGc3Rkb3V0GAMgASgMEg4KBnN0ZGVychgEIAEoDBIYCglhcnRpZmFjdHMYBSABKAsyBS5GaWxlIjIKBEZpbGUSCwoDcmVmGAEgASgJEg8KB2NvbnRlbnQYAiABKAkSDAoEYmxvYhgDIAEoDCIRCg9GaWxlTGlzdGluZ0FyZ3MiJAoTRmlsZUxpc3RpbmdSZXNwb25zZRINCgVmaWxlcxgBIAMoCSIdCg1GaWxlUHJvYmVBcmdzEgwKBGZpbGUYASABKAkiHwoRRmlsZVByb2JlUmVzcG9uc2USCgoCb2sYASABKAgiJwoORmlsZVVwbG9hZEFyZ3MSFQoGdXBsb2FkGAEgASgLMgUuRmlsZSIhChJGaWxlVXBsb2FkUmVzcG9uc2USCwoDZXJyGAEgASgJIiAKEEZpbGVEb3dubG9hZEFyZ3MSDAoEZmlsZRgBIAEoCSI8ChRGaWxlRG93bmxvYWRSZXNwb25zZRIXCghkb3dubG9hZBgBIAEoCzIFLkZpbGUSCwoDZXJyGAIgASgJIh8KDEdlbmVyaWNFdmVudBIPCgdtZXNzYWdlGAEgASgJIjAKDVByb3ZpZGVySGVsbG8SDAoEbmFtZRgBIAEoCRIRCgl1c2VyYWdlbnQYAiABKAkiNwoRUHJvdmlkZXJSZXNvdXJjZXMSEwoLY29uY3VycmVuY3kYASABKA0SDQoFdGFza3MYAiABKA0iIAoLQ2x1c3RlckluZm8SEQoJcHJvdmlkZXJzGAEgASgNIiwKClRocm91Z2hwdXQSDwoHb3ZlcmFsbBgBIAEoAhINCgV5b3VycxgCIAEoAiJDChBDbGllbnRVcGxvYWRBcmdzEgwKBG5hbWUYASABKAkSEwoLY29udGVudFR5cGUYAiABKAkSDAoEYmxvYhgDIAEoDCIwChRDbGllbnRVcGxvYWRSZXNwb25zZRILCgNyZWYYASABKAkSCwoDZXJyGAIgASgJIm4KEk9mZmxvYWRXYXNpSm9iQXJncxIVCgZiaW5hcnkYASABKAsyBS5GaWxlEiAKBmNvbW1vbhgDIAEoCzIQLk9mZmxvYWRXYXNpVGFzaxIfCgV0YXNrcxgEIAMoCzIQLk9mZmxvYWRXYXNpVGFzayJQChZPZmZsb2FkV2FzaUpvYlJlc3BvbnNlEg0KBWVycm9yGAEgASgJEicKB3Jlc3VsdHMYAyADKAsyFi5PZmZsb2FkV2FzaVRhc2tSZXN1bHQiZgoPT2ZmbG9hZFdhc2lUYXNrEgwKBGFyZ3MYASADKAkSDAoEZW52cxgCIAMoCRINCgVzdGRpbhgDIAEoDBIVCgZyb290ZnMYBCABKAsyBS5GaWxlEhEKCWFydGlmYWN0cxgFIAMoCSJwChVPZmZsb2FkV2FzaVRhc2tSZXN1bHQSDQoFZXJyb3IYASABKAkSDgoGc3RhdHVzGAIgASgFEg4KBnN0ZG91dBgDIAEoDBIOCgZzdGRlcnIYBCABKAwSGAoJYXJ0aWZhY3RzGAUgASgLMgUuRmlsZSpcCgtTdWJwcm90b2NvbBILCgdVTktOT1dOEAASIQodd2FzaW1vZmZfcHJvdmlkZXJfdjFfcHJvdG9idWYQARIdChl3YXNpbW9mZl9wcm92aWRlcl92MV9qc29uEAJiCGVkaXRpb25zcOgH", [file_google_protobuf_any]);

/**
 * Envelope is a generic message wrapper with a sequence counter and message type.
 * The payload contains a { Request, Response, Event }.
 *
 * @generated from message Envelope
 */
export type Envelope = Message<"Envelope"> & {
  /**
   * The sequence number is incremented for each message but Request and Event
   * count independently. Responses must always reuse the Request's sequence
   * number so they can be routed to the caller correctly.
   *
   * @generated from field: uint64 sequence = 1;
   */
  sequence: bigint;

  /**
   * The message type indicates the payload contents: { Request, Response, Event }.
   *
   * @generated from field: Envelope.MessageType type = 2;
   */
  type: Envelope_MessageType;

  /**
   * The presence of an error indicates that something went wrong with the call
   * in general (like a server "oops"). Otherwise, the called function should
   * encode specific errors within the payload.
   *
   * @generated from field: string error = 3;
   */
  error: string;

  /**
   * The payload itself. Needs to be (un)packed with `anypb`.
   *
   * @generated from field: google.protobuf.Any payload = 4;
   */
  payload?: Any;
};

/**
 * JSON type for the message Envelope.
 */
export type EnvelopeJson = {
  /**
   * @generated from field: uint64 sequence = 1;
   */
  sequence?: string;

  /**
   * @generated from field: Envelope.MessageType type = 2;
   */
  type?: Envelope_MessageTypeJson;

  /**
   * @generated from field: string error = 3;
   */
  error?: string;

  /**
   * @generated from field: google.protobuf.Any payload = 4;
   */
  payload?: AnyJson;
};

/**
 * Describes the message Envelope.
 * Use `create(EnvelopeSchema)` to create a new message.
 */
export const EnvelopeSchema: GenMessage<Envelope, EnvelopeJson> = /*@__PURE__*/
  messageDesc(file_messages, 0);

/**
 * @generated from enum Envelope.MessageType
 */
export enum Envelope_MessageType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: Request = 1;
   */
  Request = 1,

  /**
   * @generated from enum value: Response = 2;
   */
  Response = 2,

  /**
   * @generated from enum value: Event = 3;
   */
  Event = 3,
}

/**
 * JSON type for the enum Envelope.MessageType.
 */
export type Envelope_MessageTypeJson = "UNKNOWN" | "Request" | "Response" | "Event";

/**
 * Describes the enum Envelope.MessageType.
 */
export const Envelope_MessageTypeSchema: GenEnum<Envelope_MessageType, Envelope_MessageTypeJson> = /*@__PURE__*/
  enumDesc(file_messages, 0, 0);

/**
 * Ping stub, if the transport does not provide them. WebSocket does have its
 * own mechanism. On WebTransport, you should use a separate stream to avoid re-
 * introducing head-of-line blocking with the other RPC requests.
 *
 * @generated from message Ping
 */
export type Ping = Message<"Ping"> & {
  /**
   * @generated from field: Ping.Direction direction = 1;
   */
  direction: Ping_Direction;
};

/**
 * JSON type for the message Ping.
 */
export type PingJson = {
  /**
   * @generated from field: Ping.Direction direction = 1;
   */
  direction?: Ping_DirectionJson;
};

/**
 * Describes the message Ping.
 * Use `create(PingSchema)` to create a new message.
 */
export const PingSchema: GenMessage<Ping, PingJson> = /*@__PURE__*/
  messageDesc(file_messages, 1);

/**
 * @generated from enum Ping.Direction
 */
export enum Ping_Direction {
  /**
   * @generated from enum value: Ping = 0;
   */
  Ping = 0,

  /**
   * @generated from enum value: Pong = 1;
   */
  Pong = 1,
}

/**
 * JSON type for the enum Ping.Direction.
 */
export type Ping_DirectionJson = "Ping" | "Pong";

/**
 * Describes the enum Ping.Direction.
 */
export const Ping_DirectionSchema: GenEnum<Ping_Direction, Ping_DirectionJson> = /*@__PURE__*/
  enumDesc(file_messages, 1, 0);

/**
 * TaskMetadata contains some information about the originating task for logging
 *
 * @generated from message TaskMetadata
 */
export type TaskMetadata = Message<"TaskMetadata"> & {
  /**
   * overall job ID
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * info about the requesting client
   *
   * @generated from field: string client = 2;
   */
  client: string;

  /**
   * index within a job with multiple tasks
   *
   * @generated from field: uint64 index = 3;
   */
  index: bigint;

  /**
   * request a trace of task execution, TODO
   *
   * @generated from field: bool trace = 4;
   */
  trace: boolean;
};

/**
 * JSON type for the message TaskMetadata.
 */
export type TaskMetadataJson = {
  /**
   * @generated from field: string id = 1;
   */
  id?: string;

  /**
   * @generated from field: string client = 2;
   */
  client?: string;

  /**
   * @generated from field: uint64 index = 3;
   */
  index?: string;

  /**
   * @generated from field: bool trace = 4;
   */
  trace?: boolean;
};

/**
 * Describes the message TaskMetadata.
 * Use `create(TaskMetadataSchema)` to create a new message.
 */
export const TaskMetadataSchema: GenMessage<TaskMetadata, TaskMetadataJson> = /*@__PURE__*/
  messageDesc(file_messages, 2);

/**
 * ExecuteWasi runs a webassembly/wasi binary on the Provider
 *
 * @generated from message ExecuteWasiArgs
 */
export type ExecuteWasiArgs = Message<"ExecuteWasiArgs"> & {
  /**
   * @generated from field: TaskMetadata task = 1;
   */
  task?: TaskMetadata;

  /**
   * @generated from field: File binary = 2;
   */
  binary?: File;

  /**
   * @generated from field: repeated string args = 3;
   */
  args: string[];

  /**
   * @generated from field: repeated string envs = 4;
   */
  envs: string[];

  /**
   * @generated from field: bytes stdin = 5;
   */
  stdin: Uint8Array;

  /**
   * @generated from field: File rootfs = 6;
   */
  rootfs?: File;

  /**
   * @generated from field: repeated string artifacts = 7;
   */
  artifacts: string[];
};

/**
 * JSON type for the message ExecuteWasiArgs.
 */
export type ExecuteWasiArgsJson = {
  /**
   * @generated from field: TaskMetadata task = 1;
   */
  task?: TaskMetadataJson;

  /**
   * @generated from field: File binary = 2;
   */
  binary?: FileJson;

  /**
   * @generated from field: repeated string args = 3;
   */
  args?: string[];

  /**
   * @generated from field: repeated string envs = 4;
   */
  envs?: string[];

  /**
   * @generated from field: bytes stdin = 5;
   */
  stdin?: string;

  /**
   * @generated from field: File rootfs = 6;
   */
  rootfs?: FileJson;

  /**
   * @generated from field: repeated string artifacts = 7;
   */
  artifacts?: string[];
};

/**
 * Describes the message ExecuteWasiArgs.
 * Use `create(ExecuteWasiArgsSchema)` to create a new message.
 */
export const ExecuteWasiArgsSchema: GenMessage<ExecuteWasiArgs, ExecuteWasiArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 3);

/**
 * @generated from message ExecuteWasiResponse
 */
export type ExecuteWasiResponse = Message<"ExecuteWasiResponse"> & {
  /**
   * @generated from field: string error = 1;
   */
  error: string;

  /**
   * @generated from field: int32 status = 2;
   */
  status: number;

  /**
   * @generated from field: bytes stdout = 3;
   */
  stdout: Uint8Array;

  /**
   * @generated from field: bytes stderr = 4;
   */
  stderr: Uint8Array;

  /**
   * @generated from field: File artifacts = 5;
   */
  artifacts?: File;
};

/**
 * JSON type for the message ExecuteWasiResponse.
 */
export type ExecuteWasiResponseJson = {
  /**
   * @generated from field: string error = 1;
   */
  error?: string;

  /**
   * @generated from field: int32 status = 2;
   */
  status?: number;

  /**
   * @generated from field: bytes stdout = 3;
   */
  stdout?: string;

  /**
   * @generated from field: bytes stderr = 4;
   */
  stderr?: string;

  /**
   * @generated from field: File artifacts = 5;
   */
  artifacts?: FileJson;
};

/**
 * Describes the message ExecuteWasiResponse.
 * Use `create(ExecuteWasiResponseSchema)` to create a new message.
 */
export const ExecuteWasiResponseSchema: GenMessage<ExecuteWasiResponse, ExecuteWasiResponseJson> = /*@__PURE__*/
  messageDesc(file_messages, 4);

/**
 * File is a file reference with optional mime-type and length. The reference
 * can be a plain filename, a prefixed hash digest or a URL to fetch from. When
 * stored, a hash digest should be computed to have a stable identifier.
 *
 * @generated from message File
 */
export type File = Message<"File"> & {
  /**
   * filename, encoded digest or URL
   *
   * @generated from field: string ref = 1;
   */
  ref: string;

  /**
   * content-type in MIME notation
   *
   * @generated from field: string content = 2;
   */
  content: string;

  /**
   * the actual file contents
   *
   * @generated from field: bytes blob = 3;
   */
  blob: Uint8Array;
};

/**
 * JSON type for the message File.
 */
export type FileJson = {
  /**
   * @generated from field: string ref = 1;
   */
  ref?: string;

  /**
   * @generated from field: string content = 2;
   */
  content?: string;

  /**
   * @generated from field: bytes blob = 3;
   */
  blob?: string;
};

/**
 * Describes the message File.
 * Use `create(FileSchema)` to create a new message.
 */
export const FileSchema: GenMessage<File, FileJson> = /*@__PURE__*/
  messageDesc(file_messages, 5);

/**
 * FileListing asks for a listing of all available files on Provider
 *
 * empty
 *
 * @generated from message FileListingArgs
 */
export type FileListingArgs = Message<"FileListingArgs"> & {
};

/**
 * JSON type for the message FileListingArgs.
 */
export type FileListingArgsJson = {
};

/**
 * Describes the message FileListingArgs.
 * Use `create(FileListingArgsSchema)` to create a new message.
 */
export const FileListingArgsSchema: GenMessage<FileListingArgs, FileListingArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 6);

/**
 * @generated from message FileListingResponse
 */
export type FileListingResponse = Message<"FileListingResponse"> & {
  /**
   * @generated from field: repeated string files = 1;
   */
  files: string[];
};

/**
 * JSON type for the message FileListingResponse.
 */
export type FileListingResponseJson = {
  /**
   * @generated from field: repeated string files = 1;
   */
  files?: string[];
};

/**
 * Describes the message FileListingResponse.
 * Use `create(FileListingResponseSchema)` to create a new message.
 */
export const FileListingResponseSchema: GenMessage<FileListingResponse, FileListingResponseJson> = /*@__PURE__*/
  messageDesc(file_messages, 7);

/**
 * FileProbe checks if a certain file exists on provider
 *
 * @generated from message FileProbeArgs
 */
export type FileProbeArgs = Message<"FileProbeArgs"> & {
  /**
   * @generated from field: string file = 1;
   */
  file: string;
};

/**
 * JSON type for the message FileProbeArgs.
 */
export type FileProbeArgsJson = {
  /**
   * @generated from field: string file = 1;
   */
  file?: string;
};

/**
 * Describes the message FileProbeArgs.
 * Use `create(FileProbeArgsSchema)` to create a new message.
 */
export const FileProbeArgsSchema: GenMessage<FileProbeArgs, FileProbeArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 8);

/**
 * @generated from message FileProbeResponse
 */
export type FileProbeResponse = Message<"FileProbeResponse"> & {
  /**
   * @generated from field: bool ok = 1;
   */
  ok: boolean;
};

/**
 * JSON type for the message FileProbeResponse.
 */
export type FileProbeResponseJson = {
  /**
   * @generated from field: bool ok = 1;
   */
  ok?: boolean;
};

/**
 * Describes the message FileProbeResponse.
 * Use `create(FileProbeResponseSchema)` to create a new message.
 */
export const FileProbeResponseSchema: GenMessage<FileProbeResponse, FileProbeResponseJson> = /*@__PURE__*/
  messageDesc(file_messages, 9);

/**
 * FileUpload pushes a file to the Provider.
 *
 * @generated from message FileUploadArgs
 */
export type FileUploadArgs = Message<"FileUploadArgs"> & {
  /**
   * @generated from field: File upload = 1;
   */
  upload?: File;
};

/**
 * JSON type for the message FileUploadArgs.
 */
export type FileUploadArgsJson = {
  /**
   * @generated from field: File upload = 1;
   */
  upload?: FileJson;
};

/**
 * Describes the message FileUploadArgs.
 * Use `create(FileUploadArgsSchema)` to create a new message.
 */
export const FileUploadArgsSchema: GenMessage<FileUploadArgs, FileUploadArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 10);

/**
 * @generated from message FileUploadResponse
 */
export type FileUploadResponse = Message<"FileUploadResponse"> & {
  /**
   * @generated from field: string err = 1;
   */
  err: string;
};

/**
 * JSON type for the message FileUploadResponse.
 */
export type FileUploadResponseJson = {
  /**
   * @generated from field: string err = 1;
   */
  err?: string;
};

/**
 * Describes the message FileUploadResponse.
 * Use `create(FileUploadResponseSchema)` to create a new message.
 */
export const FileUploadResponseSchema: GenMessage<FileUploadResponse, FileUploadResponseJson> = /*@__PURE__*/
  messageDesc(file_messages, 11);

/**
 * FileDownload can be sent by the Provider to request a file download.
 *
 * @generated from message FileDownloadArgs
 */
export type FileDownloadArgs = Message<"FileDownloadArgs"> & {
  /**
   * @generated from field: string file = 1;
   */
  file: string;
};

/**
 * JSON type for the message FileDownloadArgs.
 */
export type FileDownloadArgsJson = {
  /**
   * @generated from field: string file = 1;
   */
  file?: string;
};

/**
 * Describes the message FileDownloadArgs.
 * Use `create(FileDownloadArgsSchema)` to create a new message.
 */
export const FileDownloadArgsSchema: GenMessage<FileDownloadArgs, FileDownloadArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 12);

/**
 * @generated from message FileDownloadResponse
 */
export type FileDownloadResponse = Message<"FileDownloadResponse"> & {
  /**
   * @generated from field: File download = 1;
   */
  download?: File;

  /**
   * @generated from field: string err = 2;
   */
  err: string;
};

/**
 * JSON type for the message FileDownloadResponse.
 */
export type FileDownloadResponseJson = {
  /**
   * @generated from field: File download = 1;
   */
  download?: FileJson;

  /**
   * @generated from field: string err = 2;
   */
  err?: string;
};

/**
 * Describes the message FileDownloadResponse.
 * Use `create(FileDownloadResponseSchema)` to create a new message.
 */
export const FileDownloadResponseSchema: GenMessage<FileDownloadResponse, FileDownloadResponseJson> = /*@__PURE__*/
  messageDesc(file_messages, 13);

/**
 * Generic is just a generic piece of text for debugging
 *
 * @generated from message GenericEvent
 */
export type GenericEvent = Message<"GenericEvent"> & {
  /**
   * @generated from field: string message = 1;
   */
  message: string;
};

/**
 * JSON type for the message GenericEvent.
 */
export type GenericEventJson = {
  /**
   * @generated from field: string message = 1;
   */
  message?: string;
};

/**
 * Describes the message GenericEvent.
 * Use `create(GenericEventSchema)` to create a new message.
 */
export const GenericEventSchema: GenMessage<GenericEvent, GenericEventJson> = /*@__PURE__*/
  messageDesc(file_messages, 14);

/**
 * ProviderHello is sent once at the beginning to identify the Provider
 *
 * @generated from message ProviderHello
 */
export type ProviderHello = Message<"ProviderHello"> & {
  /**
   * a logging-friendly name of the provider
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * like the navigator.useragent in browser
   *
   * @generated from field: string useragent = 2;
   */
  useragent: string;
};

/**
 * JSON type for the message ProviderHello.
 */
export type ProviderHelloJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * @generated from field: string useragent = 2;
   */
  useragent?: string;
};

/**
 * Describes the message ProviderHello.
 * Use `create(ProviderHelloSchema)` to create a new message.
 */
export const ProviderHelloSchema: GenMessage<ProviderHello, ProviderHelloJson> = /*@__PURE__*/
  messageDesc(file_messages, 15);

/**
 * ProviderResources is information about the available resources in Worker pool
 *
 * @generated from message ProviderResources
 */
export type ProviderResources = Message<"ProviderResources"> & {
  /**
   * maximum possible concurrency (~ number of Workers)
   *
   * @generated from field: uint32 concurrency = 1;
   */
  concurrency: number;

  /**
   * currently active tasks
   *
   * @generated from field: uint32 tasks = 2;
   */
  tasks: number;
};

/**
 * JSON type for the message ProviderResources.
 */
export type ProviderResourcesJson = {
  /**
   * @generated from field: uint32 concurrency = 1;
   */
  concurrency?: number;

  /**
   * @generated from field: uint32 tasks = 2;
   */
  tasks?: number;
};

/**
 * Describes the message ProviderResources.
 * Use `create(ProviderResourcesSchema)` to create a new message.
 */
export const ProviderResourcesSchema: GenMessage<ProviderResources, ProviderResourcesJson> = /*@__PURE__*/
  messageDesc(file_messages, 16);

/**
 * ClusterInfo contains information about all connected Providers
 *
 * @generated from message ClusterInfo
 */
export type ClusterInfo = Message<"ClusterInfo"> & {
  /**
   * number of currently connected providers
   *
   * @generated from field: uint32 providers = 1;
   */
  providers: number;
};

/**
 * JSON type for the message ClusterInfo.
 */
export type ClusterInfoJson = {
  /**
   * @generated from field: uint32 providers = 1;
   */
  providers?: number;
};

/**
 * Describes the message ClusterInfo.
 * Use `create(ClusterInfoSchema)` to create a new message.
 */
export const ClusterInfoSchema: GenMessage<ClusterInfo, ClusterInfoJson> = /*@__PURE__*/
  messageDesc(file_messages, 17);

/**
 * Throughput contains information about overall cluster throughput
 *
 * @generated from message Throughput
 */
export type Throughput = Message<"Throughput"> & {
  /**
   * current overall tasks/s throughput
   *
   * @generated from field: float overall = 1;
   */
  overall: number;

  /**
   * your contribution (identified by name)
   *
   * @generated from field: float yours = 2;
   */
  yours: number;
};

/**
 * JSON type for the message Throughput.
 */
export type ThroughputJson = {
  /**
   * @generated from field: float overall = 1;
   */
  overall?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * @generated from field: float yours = 2;
   */
  yours?: number | "NaN" | "Infinity" | "-Infinity";
};

/**
 * Describes the message Throughput.
 * Use `create(ThroughputSchema)` to create a new message.
 */
export const ThroughputSchema: GenMessage<Throughput, ThroughputJson> = /*@__PURE__*/
  messageDesc(file_messages, 18);

/**
 * The simplest client upload is a POST request with the raw binary inside
 * and metadata in headers but I guess we can also use a message type.
 *
 * @generated from message ClientUploadArgs
 */
export type ClientUploadArgs = Message<"ClientUploadArgs"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: string contentType = 2;
   */
  contentType: string;

  /**
   * @generated from field: bytes blob = 3;
   */
  blob: Uint8Array;
};

/**
 * JSON type for the message ClientUploadArgs.
 */
export type ClientUploadArgsJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * @generated from field: string contentType = 2;
   */
  contentType?: string;

  /**
   * @generated from field: bytes blob = 3;
   */
  blob?: string;
};

/**
 * Describes the message ClientUploadArgs.
 * Use `create(ClientUploadArgsSchema)` to create a new message.
 */
export const ClientUploadArgsSchema: GenMessage<ClientUploadArgs, ClientUploadArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 19);

/**
 * @generated from message ClientUploadResponse
 */
export type ClientUploadResponse = Message<"ClientUploadResponse"> & {
  /**
   * @generated from field: string ref = 1;
   */
  ref: string;

  /**
   * @generated from field: string err = 2;
   */
  err: string;
};

/**
 * JSON type for the message ClientUploadResponse.
 */
export type ClientUploadResponseJson = {
  /**
   * @generated from field: string ref = 1;
   */
  ref?: string;

  /**
   * @generated from field: string err = 2;
   */
  err?: string;
};

/**
 * Describes the message ClientUploadResponse.
 * Use `create(ClientUploadResponseSchema)` to create a new message.
 */
export const ClientUploadResponseSchema: GenMessage<ClientUploadResponse, ClientUploadResponseJson> = /*@__PURE__*/
  messageDesc(file_messages, 20);

/**
 * An offloading request specifies a binary to use, optionally some common
 * parent parameters and then a list of executions of this binary. There is
 * no magic in the parent parameter inheritance: anything in the parent gets
 * entirely replaced by the corresponding field in a task specification. Though
 * you could specify everything in the common parameters, at least one task
 * must be present; even if just an empty { }.
 *
 * @generated from message OffloadWasiJobArgs
 */
export type OffloadWasiJobArgs = Message<"OffloadWasiJobArgs"> & {
  /**
   * @generated from field: File binary = 1;
   */
  binary?: File;

  /**
   * bool trace = 2; // TODO
   *
   * @generated from field: OffloadWasiTask common = 3;
   */
  common?: OffloadWasiTask;

  /**
   * @generated from field: repeated OffloadWasiTask tasks = 4;
   */
  tasks: OffloadWasiTask[];
};

/**
 * JSON type for the message OffloadWasiJobArgs.
 */
export type OffloadWasiJobArgsJson = {
  /**
   * @generated from field: File binary = 1;
   */
  binary?: FileJson;

  /**
   * @generated from field: OffloadWasiTask common = 3;
   */
  common?: OffloadWasiTaskJson;

  /**
   * @generated from field: repeated OffloadWasiTask tasks = 4;
   */
  tasks?: OffloadWasiTaskJson[];
};

/**
 * Describes the message OffloadWasiJobArgs.
 * Use `create(OffloadWasiJobArgsSchema)` to create a new message.
 */
export const OffloadWasiJobArgsSchema: GenMessage<OffloadWasiJobArgs, OffloadWasiJobArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 21);

/**
 * @generated from message OffloadWasiJobResponse
 */
export type OffloadWasiJobResponse = Message<"OffloadWasiJobResponse"> & {
  /**
   * @generated from field: string error = 1;
   */
  error: string;

  /**
   * Trace trace = 2; // TODO
   *
   * @generated from field: repeated OffloadWasiTaskResult results = 3;
   */
  results: OffloadWasiTaskResult[];
};

/**
 * JSON type for the message OffloadWasiJobResponse.
 */
export type OffloadWasiJobResponseJson = {
  /**
   * @generated from field: string error = 1;
   */
  error?: string;

  /**
   * @generated from field: repeated OffloadWasiTaskResult results = 3;
   */
  results?: OffloadWasiTaskResultJson[];
};

/**
 * Describes the message OffloadWasiJobResponse.
 * Use `create(OffloadWasiJobResponseSchema)` to create a new message.
 */
export const OffloadWasiJobResponseSchema: GenMessage<OffloadWasiJobResponse, OffloadWasiJobResponseJson> = /*@__PURE__*/
  messageDesc(file_messages, 22);

/**
 * @generated from message OffloadWasiTask
 */
export type OffloadWasiTask = Message<"OffloadWasiTask"> & {
  /**
   * @generated from field: repeated string args = 1;
   */
  args: string[];

  /**
   * @generated from field: repeated string envs = 2;
   */
  envs: string[];

  /**
   * @generated from field: bytes stdin = 3;
   */
  stdin: Uint8Array;

  /**
   * @generated from field: File rootfs = 4;
   */
  rootfs?: File;

  /**
   * @generated from field: repeated string artifacts = 5;
   */
  artifacts: string[];
};

/**
 * JSON type for the message OffloadWasiTask.
 */
export type OffloadWasiTaskJson = {
  /**
   * @generated from field: repeated string args = 1;
   */
  args?: string[];

  /**
   * @generated from field: repeated string envs = 2;
   */
  envs?: string[];

  /**
   * @generated from field: bytes stdin = 3;
   */
  stdin?: string;

  /**
   * @generated from field: File rootfs = 4;
   */
  rootfs?: FileJson;

  /**
   * @generated from field: repeated string artifacts = 5;
   */
  artifacts?: string[];
};

/**
 * Describes the message OffloadWasiTask.
 * Use `create(OffloadWasiTaskSchema)` to create a new message.
 */
export const OffloadWasiTaskSchema: GenMessage<OffloadWasiTask, OffloadWasiTaskJson> = /*@__PURE__*/
  messageDesc(file_messages, 23);

/**
 * @generated from message OffloadWasiTaskResult
 */
export type OffloadWasiTaskResult = Message<"OffloadWasiTaskResult"> & {
  /**
   * @generated from field: string error = 1;
   */
  error: string;

  /**
   * @generated from field: int32 status = 2;
   */
  status: number;

  /**
   * @generated from field: bytes stdout = 3;
   */
  stdout: Uint8Array;

  /**
   * @generated from field: bytes stderr = 4;
   */
  stderr: Uint8Array;

  /**
   * @generated from field: File artifacts = 5;
   */
  artifacts?: File;
};

/**
 * JSON type for the message OffloadWasiTaskResult.
 */
export type OffloadWasiTaskResultJson = {
  /**
   * @generated from field: string error = 1;
   */
  error?: string;

  /**
   * @generated from field: int32 status = 2;
   */
  status?: number;

  /**
   * @generated from field: bytes stdout = 3;
   */
  stdout?: string;

  /**
   * @generated from field: bytes stderr = 4;
   */
  stderr?: string;

  /**
   * @generated from field: File artifacts = 5;
   */
  artifacts?: FileJson;
};

/**
 * Describes the message OffloadWasiTaskResult.
 * Use `create(OffloadWasiTaskResultSchema)` to create a new message.
 */
export const OffloadWasiTaskResultSchema: GenMessage<OffloadWasiTaskResult, OffloadWasiTaskResultJson> = /*@__PURE__*/
  messageDesc(file_messages, 24);

/**
 * Subprotocol is used to identify the concrete encoding on the wire.
 *
 * @generated from enum Subprotocol
 */
export enum Subprotocol {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * binary messages with Protobuf encoding
   *
   * @generated from enum value: wasimoff_provider_v1_protobuf = 1;
   */
  wasimoff_provider_v1_protobuf = 1,

  /**
   * text messages with JSON encoding
   *
   * @generated from enum value: wasimoff_provider_v1_json = 2;
   */
  wasimoff_provider_v1_json = 2,
}

/**
 * JSON type for the enum Subprotocol.
 */
export type SubprotocolJson = "UNKNOWN" | "wasimoff_provider_v1_protobuf" | "wasimoff_provider_v1_json";

/**
 * Describes the enum Subprotocol.
 */
export const SubprotocolSchema: GenEnum<Subprotocol, SubprotocolJson> = /*@__PURE__*/
  enumDesc(file_messages, 0);

