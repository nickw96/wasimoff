// best practices: https://protobuf.dev/programming-guides/dos-donts/

// @generated by protoc-gen-es v2.0.0 with parameter "target=ts,json_types=true"
// @generated from file messages.proto (edition 2023)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Any, AnyJson } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_any } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file messages.proto.
 */
export const file_messages: GenFile = /*@__PURE__*/
  fileDesc("Cg5tZXNzYWdlcy5wcm90byK5AQoIRW52ZWxvcGUSEAoIc2VxdWVuY2UYASABKAQSIwoEdHlwZRgCIAEoDjIVLkVudmVsb3BlLk1lc3NhZ2VUeXBlEg0KBWVycm9yGAMgASgJEiUKB3BheWxvYWQYBCABKAsyFC5nb29nbGUucHJvdG9idWYuQW55IkAKC01lc3NhZ2VUeXBlEgsKB1VOS05PV04QABILCgdSZXF1ZXN0EAESDAoIUmVzcG9uc2UQAhIJCgVFdmVudBADIksKBFBpbmcSIgoJZGlyZWN0aW9uGAEgASgOMg8uUGluZy5EaXJlY3Rpb24iHwoJRGlyZWN0aW9uEggKBFBpbmcQABIICgRQb25nEAEiSwoPRXhlY3V0ZVdhc2lBcmdzEhsKBGluZm8YASABKAsyDS5UYXNrTWV0YWRhdGESGwoEdGFzaxgCIAEoCzINLldhc2lUYXNrQXJncyJFChNFeGVjdXRlV2FzaVJlc3BvbnNlEg0KBWVycm9yGAEgASgJEh8KBnJlc3VsdBgCIAEoCzIPLldhc2lUYXNrUmVzdWx0IjwKDFRhc2tNZXRhZGF0YRINCgVqb2JJRBgBIAEoCRINCgVpbmRleBgDIAEoBBIOCgZjbGllbnQYAiABKAkiegoMV2FzaVRhc2tBcmdzEhUKBmJpbmFyeRgBIAEoCzIFLkZpbGUSDAoEYXJncxgCIAMoCRIMCgRlbnZzGAMgAygJEg0KBXN0ZGluGAQgASgMEhUKBnJvb3RmcxgFIAEoCzIFLkZpbGUSEQoJYXJ0aWZhY3RzGAYgAygJIloKDldhc2lUYXNrUmVzdWx0Eg4KBnN0YXR1cxgBIAEoBRIOCgZzdGRvdXQYAiABKAwSDgoGc3RkZXJyGAMgASgMEhgKCWFydGlmYWN0cxgEIAEoCzIFLkZpbGUiMAoERmlsZRILCgNyZWYYASABKAkSDQoFbWVkaWEYAiABKAkSDAoEYmxvYhgDIAEoDCIRCg9GaWxlTGlzdGluZ0FyZ3MiJAoTRmlsZUxpc3RpbmdSZXNwb25zZRINCgVmaWxlcxgBIAMoCSIdCg1GaWxlUHJvYmVBcmdzEgwKBGZpbGUYASABKAkiHwoRRmlsZVByb2JlUmVzcG9uc2USCgoCb2sYASABKAgiJwoORmlsZVVwbG9hZEFyZ3MSFQoGdXBsb2FkGAEgASgLMgUuRmlsZSIhChJGaWxlVXBsb2FkUmVzcG9uc2USCwoDZXJyGAEgASgJIiAKEEZpbGVEb3dubG9hZEFyZ3MSDAoEZmlsZRgBIAEoCSI8ChRGaWxlRG93bmxvYWRSZXNwb25zZRIXCghkb3dubG9hZBgBIAEoCzIFLkZpbGUSCwoDZXJyGAIgASgJIh8KDEdlbmVyaWNFdmVudBIPCgdtZXNzYWdlGAEgASgJIjAKDVByb3ZpZGVySGVsbG8SDAoEbmFtZRgBIAEoCRIRCgl1c2VyYWdlbnQYAiABKAkiNwoRUHJvdmlkZXJSZXNvdXJjZXMSEwoLY29uY3VycmVuY3kYASABKA0SDQoFdGFza3MYAiABKA0iIAoLQ2x1c3RlckluZm8SEQoJcHJvdmlkZXJzGAEgASgNIiwKClRocm91Z2hwdXQSDwoHb3ZlcmFsbBgBIAEoAhINCgV5b3VycxgCIAEoAiI9ChBDbGllbnRVcGxvYWRBcmdzEgwKBG5hbWUYASABKAkSDQoFbWVkaWEYAiABKAkSDAoEYm9keRgDIAEoDCIwChRDbGllbnRVcGxvYWRSZXNwb25zZRILCgNyZWYYASABKAkSCwoDZXJyGAIgASgJIlEKEk9mZmxvYWRXYXNpSm9iQXJncxIdCgZwYXJlbnQYASABKAsyDS5XYXNpVGFza0FyZ3MSHAoFdGFza3MYAiADKAsyDS5XYXNpVGFza0FyZ3MiTgoWT2ZmbG9hZFdhc2lKb2JSZXNwb25zZRIPCgdmYWlsdXJlGAEgASgJEiMKBXRhc2tzGAIgAygLMhQuRXhlY3V0ZVdhc2lSZXNwb25zZSpcCgtTdWJwcm90b2NvbBILCgdVTktOT1dOEAASIQodd2FzaW1vZmZfcHJvdmlkZXJfdjFfcHJvdG9idWYQARIdChl3YXNpbW9mZl9wcm92aWRlcl92MV9qc29uEAJiCGVkaXRpb25zcOgH", [file_google_protobuf_any]);

/**
 * Envelope is a generic message wrapper with a sequence counter and message type.
 * The payload contains a { Request, Response, Event }.
 *
 * @generated from message Envelope
 */
export type Envelope = Message<"Envelope"> & {
  /**
   * The sequence number is incremented for each message but Request and Event
   * count independently. Responses must always reuse the Request's sequence
   * number so they can be routed to the caller correctly.
   *
   * @generated from field: uint64 sequence = 1;
   */
  sequence: bigint;

  /**
   * The message type indicates the payload contents: { Request, Response, Event }.
   *
   * @generated from field: Envelope.MessageType type = 2;
   */
  type: Envelope_MessageType;

  /**
   * The presence of an error indicates that something went wrong with the call
   * in general (like a server "oops"). Otherwise, the called function should
   * encode specific errors within the payload.
   *
   * @generated from field: string error = 3;
   */
  error: string;

  /**
   * The payload itself. Needs to be (un)packed with `anypb`.
   *
   * @generated from field: google.protobuf.Any payload = 4;
   */
  payload?: Any;
};

/**
 * JSON type for the message Envelope.
 */
export type EnvelopeJson = {
  /**
   * @generated from field: uint64 sequence = 1;
   */
  sequence?: string;

  /**
   * @generated from field: Envelope.MessageType type = 2;
   */
  type?: Envelope_MessageTypeJson;

  /**
   * @generated from field: string error = 3;
   */
  error?: string;

  /**
   * @generated from field: google.protobuf.Any payload = 4;
   */
  payload?: AnyJson;
};

/**
 * Describes the message Envelope.
 * Use `create(EnvelopeSchema)` to create a new message.
 */
export const EnvelopeSchema: GenMessage<Envelope, EnvelopeJson> = /*@__PURE__*/
  messageDesc(file_messages, 0);

/**
 * @generated from enum Envelope.MessageType
 */
export enum Envelope_MessageType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: Request = 1;
   */
  Request = 1,

  /**
   * @generated from enum value: Response = 2;
   */
  Response = 2,

  /**
   * @generated from enum value: Event = 3;
   */
  Event = 3,
}

/**
 * JSON type for the enum Envelope.MessageType.
 */
export type Envelope_MessageTypeJson = "UNKNOWN" | "Request" | "Response" | "Event";

/**
 * Describes the enum Envelope.MessageType.
 */
export const Envelope_MessageTypeSchema: GenEnum<Envelope_MessageType, Envelope_MessageTypeJson> = /*@__PURE__*/
  enumDesc(file_messages, 0, 0);

/**
 * Ping stub, if the transport does not provide them. WebSocket does have its
 * own mechanism. On WebTransport, you should use a separate stream to avoid re-
 * introducing head-of-line blocking with the other RPC requests.
 *
 * @generated from message Ping
 */
export type Ping = Message<"Ping"> & {
  /**
   * @generated from field: Ping.Direction direction = 1;
   */
  direction: Ping_Direction;
};

/**
 * JSON type for the message Ping.
 */
export type PingJson = {
  /**
   * @generated from field: Ping.Direction direction = 1;
   */
  direction?: Ping_DirectionJson;
};

/**
 * Describes the message Ping.
 * Use `create(PingSchema)` to create a new message.
 */
export const PingSchema: GenMessage<Ping, PingJson> = /*@__PURE__*/
  messageDesc(file_messages, 1);

/**
 * @generated from enum Ping.Direction
 */
export enum Ping_Direction {
  /**
   * @generated from enum value: Ping = 0;
   */
  Ping = 0,

  /**
   * @generated from enum value: Pong = 1;
   */
  Pong = 1,
}

/**
 * JSON type for the enum Ping.Direction.
 */
export type Ping_DirectionJson = "Ping" | "Pong";

/**
 * Describes the enum Ping.Direction.
 */
export const Ping_DirectionSchema: GenEnum<Ping_Direction, Ping_DirectionJson> = /*@__PURE__*/
  enumDesc(file_messages, 1, 0);

/**
 * ExecuteWasi runs a webassembly/wasi binary on the Provider
 *
 * @generated from message ExecuteWasiArgs
 */
export type ExecuteWasiArgs = Message<"ExecuteWasiArgs"> & {
  /**
   * metadata about this task
   *
   * @generated from field: TaskMetadata info = 1;
   */
  info?: TaskMetadata;

  /**
   * arguments for the WebAssembly module
   *
   * @generated from field: WasiTaskArgs task = 2;
   */
  task?: WasiTaskArgs;
};

/**
 * JSON type for the message ExecuteWasiArgs.
 */
export type ExecuteWasiArgsJson = {
  /**
   * @generated from field: TaskMetadata info = 1;
   */
  info?: TaskMetadataJson;

  /**
   * @generated from field: WasiTaskArgs task = 2;
   */
  task?: WasiTaskArgsJson;
};

/**
 * Describes the message ExecuteWasiArgs.
 * Use `create(ExecuteWasiArgsSchema)` to create a new message.
 */
export const ExecuteWasiArgsSchema: GenMessage<ExecuteWasiArgs, ExecuteWasiArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 2);

/**
 * @generated from message ExecuteWasiResponse
 */
export type ExecuteWasiResponse = Message<"ExecuteWasiResponse"> & {
  /**
   * error leading up to the instantiation
   *
   * @generated from field: string error = 1;
   */
  error: string;

  /**
   * result of the execution
   *
   * @generated from field: WasiTaskResult result = 2;
   */
  result?: WasiTaskResult;
};

/**
 * JSON type for the message ExecuteWasiResponse.
 */
export type ExecuteWasiResponseJson = {
  /**
   * @generated from field: string error = 1;
   */
  error?: string;

  /**
   * @generated from field: WasiTaskResult result = 2;
   */
  result?: WasiTaskResultJson;
};

/**
 * Describes the message ExecuteWasiResponse.
 * Use `create(ExecuteWasiResponseSchema)` to create a new message.
 */
export const ExecuteWasiResponseSchema: GenMessage<ExecuteWasiResponse, ExecuteWasiResponseJson> = /*@__PURE__*/
  messageDesc(file_messages, 3);

/**
 * TaskMetadata contains some information about the originating job request.
 *
 * @generated from message TaskMetadata
 */
export type TaskMetadata = Message<"TaskMetadata"> & {
  /**
   * overall job ID
   *
   * @generated from field: string jobID = 1;
   */
  jobID: string;

  /**
   * index within a job with multiple tasks
   *
   * @generated from field: uint64 index = 3;
   */
  index: bigint;

  /**
   * info about the requesting client
   *
   * @generated from field: string client = 2;
   */
  client: string;
};

/**
 * JSON type for the message TaskMetadata.
 */
export type TaskMetadataJson = {
  /**
   * @generated from field: string jobID = 1;
   */
  jobID?: string;

  /**
   * @generated from field: uint64 index = 3;
   */
  index?: string;

  /**
   * @generated from field: string client = 2;
   */
  client?: string;
};

/**
 * Describes the message TaskMetadata.
 * Use `create(TaskMetadataSchema)` to create a new message.
 */
export const TaskMetadataSchema: GenMessage<TaskMetadata, TaskMetadataJson> = /*@__PURE__*/
  messageDesc(file_messages, 4);

/**
 * WasiTaskArgs should not be sent as a toplevel message directly and instead
 * contains necessary references and execution arguments to instantiate a single
 * WebAssembly task on the Provider.
 *
 * @generated from message WasiTaskArgs
 */
export type WasiTaskArgs = Message<"WasiTaskArgs"> & {
  /**
   * @generated from field: File binary = 1;
   */
  binary?: File;

  /**
   * @generated from field: repeated string args = 2;
   */
  args: string[];

  /**
   * @generated from field: repeated string envs = 3;
   */
  envs: string[];

  /**
   * @generated from field: bytes stdin = 4;
   */
  stdin: Uint8Array;

  /**
   * @generated from field: File rootfs = 5;
   */
  rootfs?: File;

  /**
   * @generated from field: repeated string artifacts = 6;
   */
  artifacts: string[];
};

/**
 * JSON type for the message WasiTaskArgs.
 */
export type WasiTaskArgsJson = {
  /**
   * @generated from field: File binary = 1;
   */
  binary?: FileJson;

  /**
   * @generated from field: repeated string args = 2;
   */
  args?: string[];

  /**
   * @generated from field: repeated string envs = 3;
   */
  envs?: string[];

  /**
   * @generated from field: bytes stdin = 4;
   */
  stdin?: string;

  /**
   * @generated from field: File rootfs = 5;
   */
  rootfs?: FileJson;

  /**
   * @generated from field: repeated string artifacts = 6;
   */
  artifacts?: string[];
};

/**
 * Describes the message WasiTaskArgs.
 * Use `create(WasiTaskArgsSchema)` to create a new message.
 */
export const WasiTaskArgsSchema: GenMessage<WasiTaskArgs, WasiTaskArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 5);

/**
 * WasiTaskResult is the result of an execution from a WasiTaskArgs. It should
 * only be returned if the module was instantiated successfully at all, i.e. any
 * errors leading up to that should be returned higher up.
 *
 * @generated from message WasiTaskResult
 */
export type WasiTaskResult = Message<"WasiTaskResult"> & {
  /**
   * @generated from field: int32 status = 1;
   */
  status: number;

  /**
   * @generated from field: bytes stdout = 2;
   */
  stdout: Uint8Array;

  /**
   * @generated from field: bytes stderr = 3;
   */
  stderr: Uint8Array;

  /**
   * @generated from field: File artifacts = 4;
   */
  artifacts?: File;
};

/**
 * JSON type for the message WasiTaskResult.
 */
export type WasiTaskResultJson = {
  /**
   * @generated from field: int32 status = 1;
   */
  status?: number;

  /**
   * @generated from field: bytes stdout = 2;
   */
  stdout?: string;

  /**
   * @generated from field: bytes stderr = 3;
   */
  stderr?: string;

  /**
   * @generated from field: File artifacts = 4;
   */
  artifacts?: FileJson;
};

/**
 * Describes the message WasiTaskResult.
 * Use `create(WasiTaskResultSchema)` to create a new message.
 */
export const WasiTaskResultSchema: GenMessage<WasiTaskResult, WasiTaskResultJson> = /*@__PURE__*/
  messageDesc(file_messages, 6);

/**
 * File is a file reference with optional mime-type. The ref could be a plain
 * filename, a prefixed hash digest or a URL to fetch from. When stored, a hash
 * digest should be computed to have a stable identifier.
 *
 * @generated from message File
 */
export type File = Message<"File"> & {
  /**
   * filename, encoded digest or URL
   *
   * @generated from field: string ref = 1;
   */
  ref: string;

  /**
   * media type in MIME notation
   *
   * @generated from field: string media = 2;
   */
  media: string;

  /**
   * the actual file contents
   *
   * @generated from field: bytes blob = 3;
   */
  blob: Uint8Array;
};

/**
 * JSON type for the message File.
 */
export type FileJson = {
  /**
   * @generated from field: string ref = 1;
   */
  ref?: string;

  /**
   * @generated from field: string media = 2;
   */
  media?: string;

  /**
   * @generated from field: bytes blob = 3;
   */
  blob?: string;
};

/**
 * Describes the message File.
 * Use `create(FileSchema)` to create a new message.
 */
export const FileSchema: GenMessage<File, FileJson> = /*@__PURE__*/
  messageDesc(file_messages, 7);

/**
 * FileListing asks for a listing of all available files on Provider
 *
 * empty
 *
 * @generated from message FileListingArgs
 */
export type FileListingArgs = Message<"FileListingArgs"> & {
};

/**
 * JSON type for the message FileListingArgs.
 */
export type FileListingArgsJson = {
};

/**
 * Describes the message FileListingArgs.
 * Use `create(FileListingArgsSchema)` to create a new message.
 */
export const FileListingArgsSchema: GenMessage<FileListingArgs, FileListingArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 8);

/**
 * @generated from message FileListingResponse
 */
export type FileListingResponse = Message<"FileListingResponse"> & {
  /**
   * @generated from field: repeated string files = 1;
   */
  files: string[];
};

/**
 * JSON type for the message FileListingResponse.
 */
export type FileListingResponseJson = {
  /**
   * @generated from field: repeated string files = 1;
   */
  files?: string[];
};

/**
 * Describes the message FileListingResponse.
 * Use `create(FileListingResponseSchema)` to create a new message.
 */
export const FileListingResponseSchema: GenMessage<FileListingResponse, FileListingResponseJson> = /*@__PURE__*/
  messageDesc(file_messages, 9);

/**
 * FileProbe checks if a certain file exists on provider
 *
 * @generated from message FileProbeArgs
 */
export type FileProbeArgs = Message<"FileProbeArgs"> & {
  /**
   * @generated from field: string file = 1;
   */
  file: string;
};

/**
 * JSON type for the message FileProbeArgs.
 */
export type FileProbeArgsJson = {
  /**
   * @generated from field: string file = 1;
   */
  file?: string;
};

/**
 * Describes the message FileProbeArgs.
 * Use `create(FileProbeArgsSchema)` to create a new message.
 */
export const FileProbeArgsSchema: GenMessage<FileProbeArgs, FileProbeArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 10);

/**
 * @generated from message FileProbeResponse
 */
export type FileProbeResponse = Message<"FileProbeResponse"> & {
  /**
   * @generated from field: bool ok = 1;
   */
  ok: boolean;
};

/**
 * JSON type for the message FileProbeResponse.
 */
export type FileProbeResponseJson = {
  /**
   * @generated from field: bool ok = 1;
   */
  ok?: boolean;
};

/**
 * Describes the message FileProbeResponse.
 * Use `create(FileProbeResponseSchema)` to create a new message.
 */
export const FileProbeResponseSchema: GenMessage<FileProbeResponse, FileProbeResponseJson> = /*@__PURE__*/
  messageDesc(file_messages, 11);

/**
 * FileUpload pushes a file to the Provider.
 *
 * @generated from message FileUploadArgs
 */
export type FileUploadArgs = Message<"FileUploadArgs"> & {
  /**
   * @generated from field: File upload = 1;
   */
  upload?: File;
};

/**
 * JSON type for the message FileUploadArgs.
 */
export type FileUploadArgsJson = {
  /**
   * @generated from field: File upload = 1;
   */
  upload?: FileJson;
};

/**
 * Describes the message FileUploadArgs.
 * Use `create(FileUploadArgsSchema)` to create a new message.
 */
export const FileUploadArgsSchema: GenMessage<FileUploadArgs, FileUploadArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 12);

/**
 * @generated from message FileUploadResponse
 */
export type FileUploadResponse = Message<"FileUploadResponse"> & {
  /**
   * @generated from field: string err = 1;
   */
  err: string;
};

/**
 * JSON type for the message FileUploadResponse.
 */
export type FileUploadResponseJson = {
  /**
   * @generated from field: string err = 1;
   */
  err?: string;
};

/**
 * Describes the message FileUploadResponse.
 * Use `create(FileUploadResponseSchema)` to create a new message.
 */
export const FileUploadResponseSchema: GenMessage<FileUploadResponse, FileUploadResponseJson> = /*@__PURE__*/
  messageDesc(file_messages, 13);

/**
 * FileDownload can be sent by the Provider to request a file download.
 *
 * @generated from message FileDownloadArgs
 */
export type FileDownloadArgs = Message<"FileDownloadArgs"> & {
  /**
   * @generated from field: string file = 1;
   */
  file: string;
};

/**
 * JSON type for the message FileDownloadArgs.
 */
export type FileDownloadArgsJson = {
  /**
   * @generated from field: string file = 1;
   */
  file?: string;
};

/**
 * Describes the message FileDownloadArgs.
 * Use `create(FileDownloadArgsSchema)` to create a new message.
 */
export const FileDownloadArgsSchema: GenMessage<FileDownloadArgs, FileDownloadArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 14);

/**
 * @generated from message FileDownloadResponse
 */
export type FileDownloadResponse = Message<"FileDownloadResponse"> & {
  /**
   * @generated from field: File download = 1;
   */
  download?: File;

  /**
   * @generated from field: string err = 2;
   */
  err: string;
};

/**
 * JSON type for the message FileDownloadResponse.
 */
export type FileDownloadResponseJson = {
  /**
   * @generated from field: File download = 1;
   */
  download?: FileJson;

  /**
   * @generated from field: string err = 2;
   */
  err?: string;
};

/**
 * Describes the message FileDownloadResponse.
 * Use `create(FileDownloadResponseSchema)` to create a new message.
 */
export const FileDownloadResponseSchema: GenMessage<FileDownloadResponse, FileDownloadResponseJson> = /*@__PURE__*/
  messageDesc(file_messages, 15);

/**
 * Generic is just a generic piece of text for debugging
 *
 * @generated from message GenericEvent
 */
export type GenericEvent = Message<"GenericEvent"> & {
  /**
   * @generated from field: string message = 1;
   */
  message: string;
};

/**
 * JSON type for the message GenericEvent.
 */
export type GenericEventJson = {
  /**
   * @generated from field: string message = 1;
   */
  message?: string;
};

/**
 * Describes the message GenericEvent.
 * Use `create(GenericEventSchema)` to create a new message.
 */
export const GenericEventSchema: GenMessage<GenericEvent, GenericEventJson> = /*@__PURE__*/
  messageDesc(file_messages, 16);

/**
 * ProviderHello is sent once at the beginning to identify the Provider
 *
 * @generated from message ProviderHello
 */
export type ProviderHello = Message<"ProviderHello"> & {
  /**
   * a logging-friendly name of the provider
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * like the navigator.useragent in browser
   *
   * @generated from field: string useragent = 2;
   */
  useragent: string;
};

/**
 * JSON type for the message ProviderHello.
 */
export type ProviderHelloJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * @generated from field: string useragent = 2;
   */
  useragent?: string;
};

/**
 * Describes the message ProviderHello.
 * Use `create(ProviderHelloSchema)` to create a new message.
 */
export const ProviderHelloSchema: GenMessage<ProviderHello, ProviderHelloJson> = /*@__PURE__*/
  messageDesc(file_messages, 17);

/**
 * ProviderResources is information about the available resources in Worker pool
 *
 * @generated from message ProviderResources
 */
export type ProviderResources = Message<"ProviderResources"> & {
  /**
   * maximum possible concurrency (~ number of Workers)
   *
   * @generated from field: uint32 concurrency = 1;
   */
  concurrency: number;

  /**
   * currently active tasks
   *
   * @generated from field: uint32 tasks = 2;
   */
  tasks: number;
};

/**
 * JSON type for the message ProviderResources.
 */
export type ProviderResourcesJson = {
  /**
   * @generated from field: uint32 concurrency = 1;
   */
  concurrency?: number;

  /**
   * @generated from field: uint32 tasks = 2;
   */
  tasks?: number;
};

/**
 * Describes the message ProviderResources.
 * Use `create(ProviderResourcesSchema)` to create a new message.
 */
export const ProviderResourcesSchema: GenMessage<ProviderResources, ProviderResourcesJson> = /*@__PURE__*/
  messageDesc(file_messages, 18);

/**
 * ClusterInfo contains information about all connected Providers
 *
 * @generated from message ClusterInfo
 */
export type ClusterInfo = Message<"ClusterInfo"> & {
  /**
   * number of currently connected providers
   *
   * @generated from field: uint32 providers = 1;
   */
  providers: number;
};

/**
 * JSON type for the message ClusterInfo.
 */
export type ClusterInfoJson = {
  /**
   * @generated from field: uint32 providers = 1;
   */
  providers?: number;
};

/**
 * Describes the message ClusterInfo.
 * Use `create(ClusterInfoSchema)` to create a new message.
 */
export const ClusterInfoSchema: GenMessage<ClusterInfo, ClusterInfoJson> = /*@__PURE__*/
  messageDesc(file_messages, 19);

/**
 * Throughput contains information about overall cluster throughput
 *
 * @generated from message Throughput
 */
export type Throughput = Message<"Throughput"> & {
  /**
   * current overall tasks/s throughput
   *
   * @generated from field: float overall = 1;
   */
  overall: number;

  /**
   * your contribution (identified by name)
   *
   * @generated from field: float yours = 2;
   */
  yours: number;
};

/**
 * JSON type for the message Throughput.
 */
export type ThroughputJson = {
  /**
   * @generated from field: float overall = 1;
   */
  overall?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * @generated from field: float yours = 2;
   */
  yours?: number | "NaN" | "Infinity" | "-Infinity";
};

/**
 * Describes the message Throughput.
 * Use `create(ThroughputSchema)` to create a new message.
 */
export const ThroughputSchema: GenMessage<Throughput, ThroughputJson> = /*@__PURE__*/
  messageDesc(file_messages, 20);

/**
 * The client upload is a POST request with the binary data as the body, media
 * type in the Contet-Type header and the optional friendly name in a query
 * parameter. So this message type isn't actually used anywhere yet.
 *
 * @generated from message ClientUploadArgs
 */
export type ClientUploadArgs = Message<"ClientUploadArgs"> & {
  /**
   * friendly name for lookup
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * media type
   *
   * @generated from field: string media = 2;
   */
  media: string;

  /**
   * binary file contents
   *
   * @generated from field: bytes body = 3;
   */
  body: Uint8Array;
};

/**
 * JSON type for the message ClientUploadArgs.
 */
export type ClientUploadArgsJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * @generated from field: string media = 2;
   */
  media?: string;

  /**
   * @generated from field: bytes body = 3;
   */
  body?: string;
};

/**
 * Describes the message ClientUploadArgs.
 * Use `create(ClientUploadArgsSchema)` to create a new message.
 */
export const ClientUploadArgsSchema: GenMessage<ClientUploadArgs, ClientUploadArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 21);

/**
 * @generated from message ClientUploadResponse
 */
export type ClientUploadResponse = Message<"ClientUploadResponse"> & {
  /**
   * the hashed ref the file was stored under
   *
   * @generated from field: string ref = 1;
   */
  ref: string;

  /**
   * any errors during file insertion
   *
   * @generated from field: string err = 2;
   */
  err: string;
};

/**
 * JSON type for the message ClientUploadResponse.
 */
export type ClientUploadResponseJson = {
  /**
   * @generated from field: string ref = 1;
   */
  ref?: string;

  /**
   * @generated from field: string err = 2;
   */
  err?: string;
};

/**
 * Describes the message ClientUploadResponse.
 * Use `create(ClientUploadResponseSchema)` to create a new message.
 */
export const ClientUploadResponseSchema: GenMessage<ClientUploadResponse, ClientUploadResponseJson> = /*@__PURE__*/
  messageDesc(file_messages, 22);

/**
 * An offloading request specifies a list of WasiTaskArgs, each possibly
 * containing a binary to use, args, envs etc. An optional common parent can
 * be given to fill values in tasks. There is no magic in the parameter
 * inheritance though: anything in the parent gets entirely replaced by the
 * corresponding field in a task spec. At least one task must always be present,
 * even if just an empty { } with all parameters inherited from the parent.
 *
 * @generated from message OffloadWasiJobArgs
 */
export type OffloadWasiJobArgs = Message<"OffloadWasiJobArgs"> & {
  /**
   * inherit common task parameters
   *
   * @generated from field: WasiTaskArgs parent = 1;
   */
  parent?: WasiTaskArgs;

  /**
   * list of task arguments
   *
   * @generated from field: repeated WasiTaskArgs tasks = 2;
   */
  tasks: WasiTaskArgs[];
};

/**
 * JSON type for the message OffloadWasiJobArgs.
 */
export type OffloadWasiJobArgsJson = {
  /**
   * @generated from field: WasiTaskArgs parent = 1;
   */
  parent?: WasiTaskArgsJson;

  /**
   * @generated from field: repeated WasiTaskArgs tasks = 2;
   */
  tasks?: WasiTaskArgsJson[];
};

/**
 * Describes the message OffloadWasiJobArgs.
 * Use `create(OffloadWasiJobArgsSchema)` to create a new message.
 */
export const OffloadWasiJobArgsSchema: GenMessage<OffloadWasiJobArgs, OffloadWasiJobArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 23);

/**
 * @generated from message OffloadWasiJobResponse
 */
export type OffloadWasiJobResponse = Message<"OffloadWasiJobResponse"> & {
  /**
   * the complete job failed
   *
   * @generated from field: string failure = 1;
   */
  failure: string;

  /**
   * list of task results
   *
   * @generated from field: repeated ExecuteWasiResponse tasks = 2;
   */
  tasks: ExecuteWasiResponse[];
};

/**
 * JSON type for the message OffloadWasiJobResponse.
 */
export type OffloadWasiJobResponseJson = {
  /**
   * @generated from field: string failure = 1;
   */
  failure?: string;

  /**
   * @generated from field: repeated ExecuteWasiResponse tasks = 2;
   */
  tasks?: ExecuteWasiResponseJson[];
};

/**
 * Describes the message OffloadWasiJobResponse.
 * Use `create(OffloadWasiJobResponseSchema)` to create a new message.
 */
export const OffloadWasiJobResponseSchema: GenMessage<OffloadWasiJobResponse, OffloadWasiJobResponseJson> = /*@__PURE__*/
  messageDesc(file_messages, 24);

/**
 * Subprotocol is used to identify the concrete encoding on the wire.
 *
 * @generated from enum Subprotocol
 */
export enum Subprotocol {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * binary messages with Protobuf encoding
   *
   * @generated from enum value: wasimoff_provider_v1_protobuf = 1;
   */
  wasimoff_provider_v1_protobuf = 1,

  /**
   * text messages with JSON encoding
   *
   * @generated from enum value: wasimoff_provider_v1_json = 2;
   */
  wasimoff_provider_v1_json = 2,
}

/**
 * JSON type for the enum Subprotocol.
 */
export type SubprotocolJson = "UNKNOWN" | "wasimoff_provider_v1_protobuf" | "wasimoff_provider_v1_json";

/**
 * Describes the enum Subprotocol.
 */
export const SubprotocolSchema: GenEnum<Subprotocol, SubprotocolJson> = /*@__PURE__*/
  enumDesc(file_messages, 0);

