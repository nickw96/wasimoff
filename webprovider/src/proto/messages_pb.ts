// best practices: https://protobuf.dev/programming-guides/dos-donts/

// @generated by protoc-gen-es v2.0.0 with parameter "target=ts,json_types=true"
// @generated from file messages.proto (edition 2023)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { Any, AnyJson, Timestamp, TimestampJson } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_any, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file messages.proto.
 */
export const file_messages: GenFile = /*@__PURE__*/
  fileDesc("Cg5tZXNzYWdlcy5wcm90byJ8CghFbnZlbG9wZRIQCghzZXF1ZW5jZRgBIAEoBBIbCgdyZXF1ZXN0GAogASgLMgguUmVxdWVzdEgAEh0KCHJlc3BvbnNlGAsgASgLMgkuUmVzcG9uc2VIABIXCgVldmVudBgMIAEoCzIGLkV2ZW50SABCCQoHbWVzc2FnZSK/AQoLRW52ZWxvcGVBbnkSEAoIc2VxdWVuY2UYASABKAQSJgoEdHlwZRgCIAEoDjIYLkVudmVsb3BlQW55Lk1lc3NhZ2VUeXBlEg0KBWVycm9yGAMgASgJEiUKB3BheWxvYWQYBCABKAsyFC5nb29nbGUucHJvdG9idWYuQW55IkAKC01lc3NhZ2VUeXBlEgsKB1VOS05PV04QABILCgdSZXF1ZXN0EAESDAoIUmVzcG9uc2UQAhIJCgVFdmVudBADIu8BCgdSZXF1ZXN0EisKD2V4ZWN1dGVXYXNpQXJncxgKIAEoCzIQLkV4ZWN1dGVXYXNpQXJnc0gAEisKD2V4ZWN1dGVXYXNtQXJncxgLIAEoCzIQLkV4ZWN1dGVXYXNtQXJnc0gAEisKD2ZpbGVMaXN0aW5nQXJncxgMIAEoCzIQLkZpbGVMaXN0aW5nQXJnc0gAEicKDWZpbGVQcm9iZUFyZ3MYDSABKAsyDi5GaWxlUHJvYmVBcmdzSAASKQoOZmlsZVVwbG9hZEFyZ3MYDiABKAsyDy5GaWxlVXBsb2FkQXJnc0gAQgkKB3JlcXVlc3QilAIKCFJlc3BvbnNlEg0KBWVycm9yGAEgASgJEi8KEWV4ZWN1dGVXYXNpUmVzdWx0GAogASgLMhIuRXhlY3V0ZVdhc2lSZXN1bHRIABIvChFleGVjdXRlV2FzbVJlc3VsdBgLIAEoCzISLkV4ZWN1dGVXYXNtUmVzdWx0SAASLwoRZmlsZUxpc3RpbmdSZXN1bHQYDCABKAsyEi5GaWxlTGlzdGluZ1Jlc3VsdEgAEisKD2ZpbGVQcm9iZVJlc3VsdBgNIAEoCzIQLkZpbGVQcm9iZVJlc3VsdEgAEi0KEGZpbGVVcGxvYWRSZXN1bHQYDiABKAsyES5GaWxlVXBsb2FkUmVzdWx0SABCCgoIcmVzcG9uc2UihQEKBUV2ZW50EhsKB2dlbmVyaWMYCiABKAsyCC5HZW5lcmljSAASJQoMcHJvdmlkZXJJbmZvGAsgASgLMg0uUHJvdmlkZXJJbmZvSAASLwoRcHJvdmlkZXJSZXNvdXJjZXMYDCABKAsyEi5Qcm92aWRlclJlc291cmNlc0gAQgcKBWV2ZW50InUKBFBpbmcSIgoJZGlyZWN0aW9uGAEgASgOMg8uUGluZy5EaXJlY3Rpb24SKAoEdGltZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAiHwoJRGlyZWN0aW9uEggKBFBpbmcQABIICgRQb25nEAEiOQoMVGFza01ldGFkYXRhEgoKAmlkGAEgASgJEg4KBmNsaWVudBgCIAEoCRINCgVpbmRleBgDIAEoBCI6CgpFeGVjdXRhYmxlEhMKCXJlZmVyZW5jZRgBIAEoCUgAEg0KA3JhdxgCIAEoDEgAQggKBmJpbmFyeSKnAQoPRXhlY3V0ZVdhc2lBcmdzEhsKBHRhc2sYASABKAsyDS5UYXNrTWV0YWRhdGESGwoGYmluYXJ5GAIgASgLMgsuRXhlY3V0YWJsZRIMCgRhcmdzGAMgAygJEgwKBGVudnMYBCADKAkSDQoFc3RkaW4YBSABKAwSDgoGbG9hZGZzGAYgAygJEhAKCGRhdGFmaWxlGAcgASgJEg0KBXRyYWNlGAggASgIInUKEUV4ZWN1dGVXYXNpUmVzdWx0Eg4KBnN0YXR1cxgBIAEoBRIOCgZzdGRvdXQYAiABKAwSDgoGc3RkZXJyGAMgASgMEhAKCGRhdGFmaWxlGAQgASgMEh4KBXRyYWNlGAUgASgLMg8uRXhlY3V0aW9uVHJhY2UiEAoORXhlY3V0aW9uVHJhY2UiWwoPRXhlY3V0ZVdhc21BcmdzEhsKBHRhc2sYASABKAsyDS5UYXNrTWV0YWRhdGESGwoGYmluYXJ5GAIgASgLMgsuRXhlY3V0YWJsZRIOCgZtZXRob2QYAyABKAkiEwoRRXhlY3V0ZVdhc21SZXN1bHQiXgoIRmlsZVN0YXQSEAoIZmlsZW5hbWUYASABKAkSEwoLY29udGVudHR5cGUYAiABKAkSDgoGbGVuZ3RoGAMgASgEEg0KBWVwb2NoGAUgASgDEgwKBGhhc2gYBCABKAwiEQoPRmlsZUxpc3RpbmdBcmdzIi0KEUZpbGVMaXN0aW5nUmVzdWx0EhgKBWZpbGVzGAEgAygLMgkuRmlsZVN0YXQiKAoNRmlsZVByb2JlQXJncxIXCgRmaWxlGAEgASgLMgkuRmlsZVN0YXQiHQoPRmlsZVByb2JlUmVzdWx0EgoKAm9rGAEgASgIIjcKDkZpbGVVcGxvYWRBcmdzEhcKBHN0YXQYASABKAsyCS5GaWxlU3RhdBIMCgRmaWxlGAIgASgMIh4KEEZpbGVVcGxvYWRSZXN1bHQSCgoCb2sYASABKAgiGgoHR2VuZXJpYxIPCgdtZXNzYWdlGAEgASgJImMKDFByb3ZpZGVySW5mbxIMCgRuYW1lGAEgASgJEhAKCHBsYXRmb3JtGAIgASgJEhEKCXVzZXJhZ2VudBgDIAEoCRIgCgRwb29sGAQgASgLMhIuUHJvdmlkZXJSZXNvdXJjZXMiNwoRUHJvdmlkZXJSZXNvdXJjZXMSEwoLY29uY3VycmVuY3kYASABKA0SDQoFdGFza3MYAiABKA0qXAoLU3VicHJvdG9jb2wSCwoHVU5LTk9XThAAEiEKHXdhc2ltb2ZmX3Byb3ZpZGVyX3YxX3Byb3RvYnVmEAESHQoZd2FzaW1vZmZfcHJvdmlkZXJfdjFfanNvbhACMooCCghQcm92aWRlchIzCgtFeGVjdXRlV2FzaRIQLkV4ZWN1dGVXYXNpQXJncxoSLkV4ZWN1dGVXYXNpUmVzdWx0EjMKC0V4ZWN1dGVXYXNtEhAuRXhlY3V0ZVdhc21BcmdzGhIuRXhlY3V0ZVdhc21SZXN1bHQSMwoLRmlsZUxpc3RpbmcSEC5GaWxlTGlzdGluZ0FyZ3MaEi5GaWxlTGlzdGluZ1Jlc3VsdBItCglGaWxlUHJvYmUSDi5GaWxlUHJvYmVBcmdzGhAuRmlsZVByb2JlUmVzdWx0EjAKCkZpbGVVcGxvYWQSDy5GaWxlVXBsb2FkQXJncxoRLkZpbGVVcGxvYWRSZXN1bHRiCGVkaXRpb25zcOgH", [file_google_protobuf_any, file_google_protobuf_timestamp]);

/**
 * Envelope contains one of [ Request | Response | Event ]. The sequence counter
 * counts independently between Request and Event.
 * Envelope is the message wrapper that contains one of [ Request | Response | Event ].
 *
 * @generated from message Envelope
 */
export type Envelope = Message<"Envelope"> & {
  /**
   * @generated from field: uint64 sequence = 1;
   */
  sequence: bigint;

  /**
   * @generated from oneof Envelope.message
   */
  message: {
    /**
     * @generated from field: Request request = 10;
     */
    value: Request;
    case: "request";
  } | {
    /**
     * @generated from field: Response response = 11;
     */
    value: Response;
    case: "response";
  } | {
    /**
     * @generated from field: Event event = 12;
     */
    value: Event;
    case: "event";
  } | { case: undefined; value?: undefined };
};

/**
 * JSON type for the message Envelope.
 */
export type EnvelopeJson = {
  /**
   * @generated from field: uint64 sequence = 1;
   */
  sequence?: string;

  /**
   * @generated from field: Request request = 10;
   */
  request?: RequestJson;

  /**
   * @generated from field: Response response = 11;
   */
  response?: ResponseJson;

  /**
   * @generated from field: Event event = 12;
   */
  event?: EventJson;
};

/**
 * Describes the message Envelope.
 * Use `create(EnvelopeSchema)` to create a new message.
 */
export const EnvelopeSchema: GenMessage<Envelope, EnvelopeJson> = /*@__PURE__*/
  messageDesc(file_messages, 0);

/**
 * EnvelopeAny is an alternative approach with an Any at the top level to reduce
 * indirection and pointer allocation in Go. DO NOT USE. This was added for a benchmark.
 *
 * @generated from message EnvelopeAny
 */
export type EnvelopeAny = Message<"EnvelopeAny"> & {
  /**
   * @generated from field: uint64 sequence = 1;
   */
  sequence: bigint;

  /**
   * @generated from field: EnvelopeAny.MessageType type = 2;
   */
  type: EnvelopeAny_MessageType;

  /**
   * @generated from field: string error = 3;
   */
  error: string;

  /**
   * @generated from field: google.protobuf.Any payload = 4;
   */
  payload?: Any;
};

/**
 * JSON type for the message EnvelopeAny.
 */
export type EnvelopeAnyJson = {
  /**
   * @generated from field: uint64 sequence = 1;
   */
  sequence?: string;

  /**
   * @generated from field: EnvelopeAny.MessageType type = 2;
   */
  type?: EnvelopeAny_MessageTypeJson;

  /**
   * @generated from field: string error = 3;
   */
  error?: string;

  /**
   * @generated from field: google.protobuf.Any payload = 4;
   */
  payload?: AnyJson;
};

/**
 * Describes the message EnvelopeAny.
 * Use `create(EnvelopeAnySchema)` to create a new message.
 */
export const EnvelopeAnySchema: GenMessage<EnvelopeAny, EnvelopeAnyJson> = /*@__PURE__*/
  messageDesc(file_messages, 1);

/**
 * @generated from enum EnvelopeAny.MessageType
 */
export enum EnvelopeAny_MessageType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: Request = 1;
   */
  Request = 1,

  /**
   * @generated from enum value: Response = 2;
   */
  Response = 2,

  /**
   * @generated from enum value: Event = 3;
   */
  Event = 3,
}

/**
 * JSON type for the enum EnvelopeAny.MessageType.
 */
export type EnvelopeAny_MessageTypeJson = "UNKNOWN" | "Request" | "Response" | "Event";

/**
 * Describes the enum EnvelopeAny.MessageType.
 */
export const EnvelopeAny_MessageTypeSchema: GenEnum<EnvelopeAny_MessageType, EnvelopeAny_MessageTypeJson> = /*@__PURE__*/
  enumDesc(file_messages, 1, 0);

/**
 * Request is an RPC request with some payload. The sequence number is used
 * in responses, so the caller can correctly route the pending response.
 *
 * @generated from message Request
 */
export type Request = Message<"Request"> & {
  /**
   * @generated from oneof Request.request
   */
  request: {
    /**
     * @generated from field: ExecuteWasiArgs executeWasiArgs = 10;
     */
    value: ExecuteWasiArgs;
    case: "executeWasiArgs";
  } | {
    /**
     * @generated from field: ExecuteWasmArgs executeWasmArgs = 11;
     */
    value: ExecuteWasmArgs;
    case: "executeWasmArgs";
  } | {
    /**
     * @generated from field: FileListingArgs fileListingArgs = 12;
     */
    value: FileListingArgs;
    case: "fileListingArgs";
  } | {
    /**
     * @generated from field: FileProbeArgs fileProbeArgs = 13;
     */
    value: FileProbeArgs;
    case: "fileProbeArgs";
  } | {
    /**
     * @generated from field: FileUploadArgs fileUploadArgs = 14;
     */
    value: FileUploadArgs;
    case: "fileUploadArgs";
  } | { case: undefined; value?: undefined };
};

/**
 * JSON type for the message Request.
 */
export type RequestJson = {
  /**
   * @generated from field: ExecuteWasiArgs executeWasiArgs = 10;
   */
  executeWasiArgs?: ExecuteWasiArgsJson;

  /**
   * @generated from field: ExecuteWasmArgs executeWasmArgs = 11;
   */
  executeWasmArgs?: ExecuteWasmArgsJson;

  /**
   * @generated from field: FileListingArgs fileListingArgs = 12;
   */
  fileListingArgs?: FileListingArgsJson;

  /**
   * @generated from field: FileProbeArgs fileProbeArgs = 13;
   */
  fileProbeArgs?: FileProbeArgsJson;

  /**
   * @generated from field: FileUploadArgs fileUploadArgs = 14;
   */
  fileUploadArgs?: FileUploadArgsJson;
};

/**
 * Describes the message Request.
 * Use `create(RequestSchema)` to create a new message.
 */
export const RequestSchema: GenMessage<Request, RequestJson> = /*@__PURE__*/
  messageDesc(file_messages, 2);

/**
 * Response is the reply to an RPC request with the same sequence number.
 * The presence of an error indicates that something went wrong with the call
 * in general (like a server "oops"). Otherwise, the called function may encode
 * its own error within the payload.
 *
 * @generated from message Response
 */
export type Response = Message<"Response"> & {
  /**
   * nil => ok
   *
   * @generated from field: string error = 1;
   */
  error: string;

  /**
   * @generated from oneof Response.response
   */
  response: {
    /**
     * @generated from field: ExecuteWasiResult executeWasiResult = 10;
     */
    value: ExecuteWasiResult;
    case: "executeWasiResult";
  } | {
    /**
     * @generated from field: ExecuteWasmResult executeWasmResult = 11;
     */
    value: ExecuteWasmResult;
    case: "executeWasmResult";
  } | {
    /**
     * @generated from field: FileListingResult fileListingResult = 12;
     */
    value: FileListingResult;
    case: "fileListingResult";
  } | {
    /**
     * @generated from field: FileProbeResult fileProbeResult = 13;
     */
    value: FileProbeResult;
    case: "fileProbeResult";
  } | {
    /**
     * @generated from field: FileUploadResult fileUploadResult = 14;
     */
    value: FileUploadResult;
    case: "fileUploadResult";
  } | { case: undefined; value?: undefined };
};

/**
 * JSON type for the message Response.
 */
export type ResponseJson = {
  /**
   * @generated from field: string error = 1;
   */
  error?: string;

  /**
   * @generated from field: ExecuteWasiResult executeWasiResult = 10;
   */
  executeWasiResult?: ExecuteWasiResultJson;

  /**
   * @generated from field: ExecuteWasmResult executeWasmResult = 11;
   */
  executeWasmResult?: ExecuteWasmResultJson;

  /**
   * @generated from field: FileListingResult fileListingResult = 12;
   */
  fileListingResult?: FileListingResultJson;

  /**
   * @generated from field: FileProbeResult fileProbeResult = 13;
   */
  fileProbeResult?: FileProbeResultJson;

  /**
   * @generated from field: FileUploadResult fileUploadResult = 14;
   */
  fileUploadResult?: FileUploadResultJson;
};

/**
 * Describes the message Response.
 * Use `create(ResponseSchema)` to create a new message.
 */
export const ResponseSchema: GenMessage<Response, ResponseJson> = /*@__PURE__*/
  messageDesc(file_messages, 3);

/**
 * Event is a simple informative message that expects no reply.
 *
 * @generated from message Event
 */
export type Event = Message<"Event"> & {
  /**
   * @generated from oneof Event.event
   */
  event: {
    /**
     * @generated from field: Generic generic = 10;
     */
    value: Generic;
    case: "generic";
  } | {
    /**
     * @generated from field: ProviderInfo providerInfo = 11;
     */
    value: ProviderInfo;
    case: "providerInfo";
  } | {
    /**
     * @generated from field: ProviderResources providerResources = 12;
     */
    value: ProviderResources;
    case: "providerResources";
  } | { case: undefined; value?: undefined };
};

/**
 * JSON type for the message Event.
 */
export type EventJson = {
  /**
   * @generated from field: Generic generic = 10;
   */
  generic?: GenericJson;

  /**
   * @generated from field: ProviderInfo providerInfo = 11;
   */
  providerInfo?: ProviderInfoJson;

  /**
   * @generated from field: ProviderResources providerResources = 12;
   */
  providerResources?: ProviderResourcesJson;
};

/**
 * Describes the message Event.
 * Use `create(EventSchema)` to create a new message.
 */
export const EventSchema: GenMessage<Event, EventJson> = /*@__PURE__*/
  messageDesc(file_messages, 4);

/**
 * Ping stub, if the transport does not provide them. WebSocket does have its
 * own mechanism. On WebTransport, you should use a separate stream to avoid re-
 * introducing head-of-line blocking with the other RPC requests; so Ping is
 * *not* in the Evelope oneof above.
 *
 * @generated from message Ping
 */
export type Ping = Message<"Ping"> & {
  /**
   * @generated from field: Ping.Direction direction = 1;
   */
  direction: Ping_Direction;

  /**
   * @generated from field: google.protobuf.Timestamp time = 2;
   */
  time?: Timestamp;
};

/**
 * JSON type for the message Ping.
 */
export type PingJson = {
  /**
   * @generated from field: Ping.Direction direction = 1;
   */
  direction?: Ping_DirectionJson;

  /**
   * @generated from field: google.protobuf.Timestamp time = 2;
   */
  time?: TimestampJson;
};

/**
 * Describes the message Ping.
 * Use `create(PingSchema)` to create a new message.
 */
export const PingSchema: GenMessage<Ping, PingJson> = /*@__PURE__*/
  messageDesc(file_messages, 5);

/**
 * @generated from enum Ping.Direction
 */
export enum Ping_Direction {
  /**
   * @generated from enum value: Ping = 0;
   */
  Ping = 0,

  /**
   * @generated from enum value: Pong = 1;
   */
  Pong = 1,
}

/**
 * JSON type for the enum Ping.Direction.
 */
export type Ping_DirectionJson = "Ping" | "Pong";

/**
 * Describes the enum Ping.Direction.
 */
export const Ping_DirectionSchema: GenEnum<Ping_Direction, Ping_DirectionJson> = /*@__PURE__*/
  enumDesc(file_messages, 5, 0);

/**
 * TaskMetadata contains some information about the originating task for logging
 *
 * @generated from message TaskMetadata
 */
export type TaskMetadata = Message<"TaskMetadata"> & {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * @generated from field: string client = 2;
   */
  client: string;

  /**
   * within a job with multiple tasks
   *
   * @generated from field: uint64 index = 3;
   */
  index: bigint;
};

/**
 * JSON type for the message TaskMetadata.
 */
export type TaskMetadataJson = {
  /**
   * @generated from field: string id = 1;
   */
  id?: string;

  /**
   * @generated from field: string client = 2;
   */
  client?: string;

  /**
   * @generated from field: uint64 index = 3;
   */
  index?: string;
};

/**
 * Describes the message TaskMetadata.
 * Use `create(TaskMetadataSchema)` to create a new message.
 */
export const TaskMetadataSchema: GenMessage<TaskMetadata, TaskMetadataJson> = /*@__PURE__*/
  messageDesc(file_messages, 6);

/**
 * Executable can be either a string reference or the raw binary itself
 *
 * @generated from message Executable
 */
export type Executable = Message<"Executable"> & {
  /**
   * @generated from oneof Executable.binary
   */
  binary: {
    /**
     * @generated from field: string reference = 1;
     */
    value: string;
    case: "reference";
  } | {
    /**
     * @generated from field: bytes raw = 2;
     */
    value: Uint8Array;
    case: "raw";
  } | { case: undefined; value?: undefined };
};

/**
 * JSON type for the message Executable.
 */
export type ExecutableJson = {
  /**
   * @generated from field: string reference = 1;
   */
  reference?: string;

  /**
   * @generated from field: bytes raw = 2;
   */
  raw?: string;
};

/**
 * Describes the message Executable.
 * Use `create(ExecutableSchema)` to create a new message.
 */
export const ExecutableSchema: GenMessage<Executable, ExecutableJson> = /*@__PURE__*/
  messageDesc(file_messages, 7);

/**
 * ExecuteWasi runs a webassembly/wasi binary on the Provider
 *
 * @generated from message ExecuteWasiArgs
 */
export type ExecuteWasiArgs = Message<"ExecuteWasiArgs"> & {
  /**
   * @generated from field: TaskMetadata task = 1;
   */
  task?: TaskMetadata;

  /**
   * @generated from field: Executable binary = 2;
   */
  binary?: Executable;

  /**
   * @generated from field: repeated string args = 3;
   */
  args: string[];

  /**
   * @generated from field: repeated string envs = 4;
   */
  envs: string[];

  /**
   * @generated from field: bytes stdin = 5;
   */
  stdin: Uint8Array;

  /**
   * TODO: replace with complete rootfs archive
   *
   * @generated from field: repeated string loadfs = 6;
   */
  loadfs: string[];

  /**
   * @generated from field: string datafile = 7;
   */
  datafile: string;

  /**
   * @generated from field: bool trace = 8;
   */
  trace: boolean;
};

/**
 * JSON type for the message ExecuteWasiArgs.
 */
export type ExecuteWasiArgsJson = {
  /**
   * @generated from field: TaskMetadata task = 1;
   */
  task?: TaskMetadataJson;

  /**
   * @generated from field: Executable binary = 2;
   */
  binary?: ExecutableJson;

  /**
   * @generated from field: repeated string args = 3;
   */
  args?: string[];

  /**
   * @generated from field: repeated string envs = 4;
   */
  envs?: string[];

  /**
   * @generated from field: bytes stdin = 5;
   */
  stdin?: string;

  /**
   * @generated from field: repeated string loadfs = 6;
   */
  loadfs?: string[];

  /**
   * @generated from field: string datafile = 7;
   */
  datafile?: string;

  /**
   * @generated from field: bool trace = 8;
   */
  trace?: boolean;
};

/**
 * Describes the message ExecuteWasiArgs.
 * Use `create(ExecuteWasiArgsSchema)` to create a new message.
 */
export const ExecuteWasiArgsSchema: GenMessage<ExecuteWasiArgs, ExecuteWasiArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 8);

/**
 * @generated from message ExecuteWasiResult
 */
export type ExecuteWasiResult = Message<"ExecuteWasiResult"> & {
  /**
   * @generated from field: int32 status = 1;
   */
  status: number;

  /**
   * @generated from field: bytes stdout = 2;
   */
  stdout: Uint8Array;

  /**
   * @generated from field: bytes stderr = 3;
   */
  stderr: Uint8Array;

  /**
   * @generated from field: bytes datafile = 4;
   */
  datafile: Uint8Array;

  /**
   * @generated from field: ExecutionTrace trace = 5;
   */
  trace?: ExecutionTrace;
};

/**
 * JSON type for the message ExecuteWasiResult.
 */
export type ExecuteWasiResultJson = {
  /**
   * @generated from field: int32 status = 1;
   */
  status?: number;

  /**
   * @generated from field: bytes stdout = 2;
   */
  stdout?: string;

  /**
   * @generated from field: bytes stderr = 3;
   */
  stderr?: string;

  /**
   * @generated from field: bytes datafile = 4;
   */
  datafile?: string;

  /**
   * @generated from field: ExecutionTrace trace = 5;
   */
  trace?: ExecutionTraceJson;
};

/**
 * Describes the message ExecuteWasiResult.
 * Use `create(ExecuteWasiResultSchema)` to create a new message.
 */
export const ExecuteWasiResultSchema: GenMessage<ExecuteWasiResult, ExecuteWasiResultJson> = /*@__PURE__*/
  messageDesc(file_messages, 9);

/**
 * TODO
 *
 * @generated from message ExecutionTrace
 */
export type ExecutionTrace = Message<"ExecutionTrace"> & {
};

/**
 * JSON type for the message ExecutionTrace.
 */
export type ExecutionTraceJson = {
};

/**
 * Describes the message ExecutionTrace.
 * Use `create(ExecutionTraceSchema)` to create a new message.
 */
export const ExecutionTraceSchema: GenMessage<ExecutionTrace, ExecutionTraceJson> = /*@__PURE__*/
  messageDesc(file_messages, 10);

/**
 * ExecuteWasm runs a webassembly/plain binary on the Provider
 *
 * @generated from message ExecuteWasmArgs
 */
export type ExecuteWasmArgs = Message<"ExecuteWasmArgs"> & {
  /**
   * @generated from field: TaskMetadata task = 1;
   */
  task?: TaskMetadata;

  /**
   * @generated from field: Executable binary = 2;
   */
  binary?: Executable;

  /**
   * TODO: how to encode plain parameters?
   *
   * @generated from field: string method = 3;
   */
  method: string;
};

/**
 * JSON type for the message ExecuteWasmArgs.
 */
export type ExecuteWasmArgsJson = {
  /**
   * @generated from field: TaskMetadata task = 1;
   */
  task?: TaskMetadataJson;

  /**
   * @generated from field: Executable binary = 2;
   */
  binary?: ExecutableJson;

  /**
   * @generated from field: string method = 3;
   */
  method?: string;
};

/**
 * Describes the message ExecuteWasmArgs.
 * Use `create(ExecuteWasmArgsSchema)` to create a new message.
 */
export const ExecuteWasmArgsSchema: GenMessage<ExecuteWasmArgs, ExecuteWasmArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 11);

/**
 * TODO
 *
 * @generated from message ExecuteWasmResult
 */
export type ExecuteWasmResult = Message<"ExecuteWasmResult"> & {
};

/**
 * JSON type for the message ExecuteWasmResult.
 */
export type ExecuteWasmResultJson = {
};

/**
 * Describes the message ExecuteWasmResult.
 * Use `create(ExecuteWasmResultSchema)` to create a new message.
 */
export const ExecuteWasmResultSchema: GenMessage<ExecuteWasmResult, ExecuteWasmResultJson> = /*@__PURE__*/
  messageDesc(file_messages, 12);

/**
 * FileStat contains metadata about a file for identification in other messages
 *
 * @generated from message FileStat
 */
export type FileStat = Message<"FileStat"> & {
  /**
   * @generated from field: string filename = 1;
   */
  filename: string;

  /**
   * @generated from field: string contenttype = 2;
   */
  contenttype: string;

  /**
   * @generated from field: uint64 length = 3;
   */
  length: bigint;

  /**
   * @generated from field: int64 epoch = 5;
   */
  epoch: bigint;

  /**
   * @generated from field: bytes hash = 4;
   */
  hash: Uint8Array;
};

/**
 * JSON type for the message FileStat.
 */
export type FileStatJson = {
  /**
   * @generated from field: string filename = 1;
   */
  filename?: string;

  /**
   * @generated from field: string contenttype = 2;
   */
  contenttype?: string;

  /**
   * @generated from field: uint64 length = 3;
   */
  length?: string;

  /**
   * @generated from field: int64 epoch = 5;
   */
  epoch?: string;

  /**
   * @generated from field: bytes hash = 4;
   */
  hash?: string;
};

/**
 * Describes the message FileStat.
 * Use `create(FileStatSchema)` to create a new message.
 */
export const FileStatSchema: GenMessage<FileStat, FileStatJson> = /*@__PURE__*/
  messageDesc(file_messages, 13);

/**
 * FileListing asks for a listing of all available files on Provider
 *
 * empty
 *
 * @generated from message FileListingArgs
 */
export type FileListingArgs = Message<"FileListingArgs"> & {
};

/**
 * JSON type for the message FileListingArgs.
 */
export type FileListingArgsJson = {
};

/**
 * Describes the message FileListingArgs.
 * Use `create(FileListingArgsSchema)` to create a new message.
 */
export const FileListingArgsSchema: GenMessage<FileListingArgs, FileListingArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 14);

/**
 * @generated from message FileListingResult
 */
export type FileListingResult = Message<"FileListingResult"> & {
  /**
   * @generated from field: repeated FileStat files = 1;
   */
  files: FileStat[];
};

/**
 * JSON type for the message FileListingResult.
 */
export type FileListingResultJson = {
  /**
   * @generated from field: repeated FileStat files = 1;
   */
  files?: FileStatJson[];
};

/**
 * Describes the message FileListingResult.
 * Use `create(FileListingResultSchema)` to create a new message.
 */
export const FileListingResultSchema: GenMessage<FileListingResult, FileListingResultJson> = /*@__PURE__*/
  messageDesc(file_messages, 15);

/**
 * FileProbe checks if a certain file exists on provider
 *
 * @generated from message FileProbeArgs
 */
export type FileProbeArgs = Message<"FileProbeArgs"> & {
  /**
   * @generated from field: FileStat file = 1;
   */
  file?: FileStat;
};

/**
 * JSON type for the message FileProbeArgs.
 */
export type FileProbeArgsJson = {
  /**
   * @generated from field: FileStat file = 1;
   */
  file?: FileStatJson;
};

/**
 * Describes the message FileProbeArgs.
 * Use `create(FileProbeArgsSchema)` to create a new message.
 */
export const FileProbeArgsSchema: GenMessage<FileProbeArgs, FileProbeArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 16);

/**
 * @generated from message FileProbeResult
 */
export type FileProbeResult = Message<"FileProbeResult"> & {
  /**
   * @generated from field: bool ok = 1;
   */
  ok: boolean;
};

/**
 * JSON type for the message FileProbeResult.
 */
export type FileProbeResultJson = {
  /**
   * @generated from field: bool ok = 1;
   */
  ok?: boolean;
};

/**
 * Describes the message FileProbeResult.
 * Use `create(FileProbeResultSchema)` to create a new message.
 */
export const FileProbeResultSchema: GenMessage<FileProbeResult, FileProbeResultJson> = /*@__PURE__*/
  messageDesc(file_messages, 17);

/**
 * FileUpload pushes a file to the Provider.
 * TODO: to be replaced with on-demand client-side fetch
 *
 * @generated from message FileUploadArgs
 */
export type FileUploadArgs = Message<"FileUploadArgs"> & {
  /**
   * @generated from field: FileStat stat = 1;
   */
  stat?: FileStat;

  /**
   * @generated from field: bytes file = 2;
   */
  file: Uint8Array;
};

/**
 * JSON type for the message FileUploadArgs.
 */
export type FileUploadArgsJson = {
  /**
   * @generated from field: FileStat stat = 1;
   */
  stat?: FileStatJson;

  /**
   * @generated from field: bytes file = 2;
   */
  file?: string;
};

/**
 * Describes the message FileUploadArgs.
 * Use `create(FileUploadArgsSchema)` to create a new message.
 */
export const FileUploadArgsSchema: GenMessage<FileUploadArgs, FileUploadArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 18);

/**
 * @generated from message FileUploadResult
 */
export type FileUploadResult = Message<"FileUploadResult"> & {
  /**
   * @generated from field: bool ok = 1;
   */
  ok: boolean;
};

/**
 * JSON type for the message FileUploadResult.
 */
export type FileUploadResultJson = {
  /**
   * @generated from field: bool ok = 1;
   */
  ok?: boolean;
};

/**
 * Describes the message FileUploadResult.
 * Use `create(FileUploadResultSchema)` to create a new message.
 */
export const FileUploadResultSchema: GenMessage<FileUploadResult, FileUploadResultJson> = /*@__PURE__*/
  messageDesc(file_messages, 19);

/**
 * Generic is just a generic piece of text for debugging
 *
 * @generated from message Generic
 */
export type Generic = Message<"Generic"> & {
  /**
   * @generated from field: string message = 1;
   */
  message: string;
};

/**
 * JSON type for the message Generic.
 */
export type GenericJson = {
  /**
   * @generated from field: string message = 1;
   */
  message?: string;
};

/**
 * Describes the message Generic.
 * Use `create(GenericSchema)` to create a new message.
 */
export const GenericSchema: GenMessage<Generic, GenericJson> = /*@__PURE__*/
  messageDesc(file_messages, 20);

/**
 * ProviderInfo is sent once at the beginning to identify the Provider
 *
 * @generated from message ProviderInfo
 */
export type ProviderInfo = Message<"ProviderInfo"> & {
  /**
   * a logging-friendly name of the provider // TODO: make a persistent ID?
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * like the navigator.platform in browser
   *
   * @generated from field: string platform = 2;
   */
  platform: string;

  /**
   * like the navigator.useragent in browser
   *
   * @generated from field: string useragent = 3;
   */
  useragent: string;

  /**
   * @generated from field: ProviderResources pool = 4;
   */
  pool?: ProviderResources;
};

/**
 * JSON type for the message ProviderInfo.
 */
export type ProviderInfoJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * @generated from field: string platform = 2;
   */
  platform?: string;

  /**
   * @generated from field: string useragent = 3;
   */
  useragent?: string;

  /**
   * @generated from field: ProviderResources pool = 4;
   */
  pool?: ProviderResourcesJson;
};

/**
 * Describes the message ProviderInfo.
 * Use `create(ProviderInfoSchema)` to create a new message.
 */
export const ProviderInfoSchema: GenMessage<ProviderInfo, ProviderInfoJson> = /*@__PURE__*/
  messageDesc(file_messages, 21);

/**
 * ProviderResources is information about the available resources in Worker pool
 *
 * @generated from message ProviderResources
 */
export type ProviderResources = Message<"ProviderResources"> & {
  /**
   * maximum possible concurrency
   *
   * @generated from field: uint32 concurrency = 1;
   */
  concurrency: number;

  /**
   * currently active tasks
   *
   * @generated from field: uint32 tasks = 2;
   */
  tasks: number;
};

/**
 * JSON type for the message ProviderResources.
 */
export type ProviderResourcesJson = {
  /**
   * @generated from field: uint32 concurrency = 1;
   */
  concurrency?: number;

  /**
   * @generated from field: uint32 tasks = 2;
   */
  tasks?: number;
};

/**
 * Describes the message ProviderResources.
 * Use `create(ProviderResourcesSchema)` to create a new message.
 */
export const ProviderResourcesSchema: GenMessage<ProviderResources, ProviderResourcesJson> = /*@__PURE__*/
  messageDesc(file_messages, 22);

/**
 * Subprotocol is used to identify the concrete encoding on the wire.
 *
 * @generated from enum Subprotocol
 */
export enum Subprotocol {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * binary messages with Protobuf encoding
   *
   * @generated from enum value: wasimoff_provider_v1_protobuf = 1;
   */
  wasimoff_provider_v1_protobuf = 1,

  /**
   * text messages with JSON encoding
   *
   * @generated from enum value: wasimoff_provider_v1_json = 2;
   */
  wasimoff_provider_v1_json = 2,
}

/**
 * JSON type for the enum Subprotocol.
 */
export type SubprotocolJson = "UNKNOWN" | "wasimoff_provider_v1_protobuf" | "wasimoff_provider_v1_json";

/**
 * Describes the enum Subprotocol.
 */
export const SubprotocolSchema: GenEnum<Subprotocol, SubprotocolJson> = /*@__PURE__*/
  enumDesc(file_messages, 0);

/**
 * we're not using gRPC but we can codify the expected request-response pairs anyway
 *
 * @generated from service Provider
 */
export const Provider: GenService<{
  /**
   * execute
   *
   * @generated from rpc Provider.ExecuteWasi
   */
  executeWasi: {
    methodKind: "unary";
    input: typeof ExecuteWasiArgsSchema;
    output: typeof ExecuteWasiResultSchema;
  },
  /**
   * @generated from rpc Provider.ExecuteWasm
   */
  executeWasm: {
    methodKind: "unary";
    input: typeof ExecuteWasmArgsSchema;
    output: typeof ExecuteWasmResultSchema;
  },
  /**
   * filesystem
   *
   * @generated from rpc Provider.FileListing
   */
  fileListing: {
    methodKind: "unary";
    input: typeof FileListingArgsSchema;
    output: typeof FileListingResultSchema;
  },
  /**
   * @generated from rpc Provider.FileProbe
   */
  fileProbe: {
    methodKind: "unary";
    input: typeof FileProbeArgsSchema;
    output: typeof FileProbeResultSchema;
  },
  /**
   * @generated from rpc Provider.FileUpload
   */
  fileUpload: {
    methodKind: "unary";
    input: typeof FileUploadArgsSchema;
    output: typeof FileUploadResultSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_messages, 0);

