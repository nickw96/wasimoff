// best practices: https://protobuf.dev/programming-guides/dos-donts/

// @generated by protoc-gen-es v2.0.0 with parameter "target=ts,json_types=true"
// @generated from file messages.proto (edition 2023)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { Any, AnyJson, Timestamp, TimestampJson } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_any, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file messages.proto.
 */
export const file_messages: GenFile = /*@__PURE__*/
  fileDesc("Cg5tZXNzYWdlcy5wcm90byJqCghFbnZlbG9wZRIbCgdyZXF1ZXN0GAEgASgLMgguUmVxdWVzdEgAEh0KCHJlc3BvbnNlGAIgASgLMgkuUmVzcG9uc2VIABIXCgVldmVudBgDIAEoCzIGLkV2ZW50SABCCQoHbWVzc2FnZSJCCgdSZXF1ZXN0EhAKCHNlcXVlbmNlGAEgASgEEiUKB3JlcXVlc3QYAyABKAsyFC5nb29nbGUucHJvdG9idWYuQW55IlMKCFJlc3BvbnNlEhAKCHNlcXVlbmNlGAEgASgEEg0KBWVycm9yGAIgASgJEiYKCHJlc3BvbnNlGAMgASgLMhQuZ29vZ2xlLnByb3RvYnVmLkFueSI+CgVFdmVudBIQCghzZXF1ZW5jZRgBIAEoBBIjCgVldmVudBgDIAEoCzIULmdvb2dsZS5wcm90b2J1Zi5BbnkidQoEUGluZxIiCglkaXJlY3Rpb24YASABKA4yDy5QaW5nLkRpcmVjdGlvbhIoCgR0aW1lGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCIfCglEaXJlY3Rpb24SCAoEUGluZxAAEggKBFBvbmcQASI5CgxUYXNrTWV0YWRhdGESCgoCaWQYASABKAkSDgoGY2xpZW50GAIgASgJEg0KBWluZGV4GAMgASgEIjoKCkV4ZWN1dGFibGUSEwoJcmVmZXJlbmNlGAEgASgJSAASDQoDcmF3GAIgASgMSABCCAoGYmluYXJ5IoYBCg9FeGVjdXRlV2FzaUFyZ3MSGwoEdGFzaxgBIAEoCzINLlRhc2tNZXRhZGF0YRIbCgZiaW5hcnkYAiABKAsyCy5FeGVjdXRhYmxlEgwKBGFyZ3MYAyADKAkSDAoEZW52cxgEIAMoCRINCgVzdGRpbhgFIAEoDBIOCgZsb2FkZnMYBiADKAkiEwoRRXhlY3V0ZVdhc2lSZXN1bHQiWwoPRXhlY3V0ZVdhc21BcmdzEhsKBHRhc2sYASABKAsyDS5UYXNrTWV0YWRhdGESGwoGYmluYXJ5GAIgASgLMgsuRXhlY3V0YWJsZRIOCgZtZXRob2QYAyABKAkiEwoRRXhlY3V0ZVdhc21SZXN1bHQiXgoIRmlsZVN0YXQSEAoIZmlsZW5hbWUYASABKAkSEwoLY29udGVudHR5cGUYAiABKAkSDgoGbGVuZ3RoGAMgASgEEg0KBWVwb2NoGAUgASgEEgwKBGhhc2gYBCABKAwiEQoPRmlsZUxpc3RpbmdBcmdzIi0KEUZpbGVMaXN0aW5nUmVzdWx0EhgKBWZpbGVzGAEgAygLMgkuRmlsZVN0YXQiKQoNRmlsZVByb2JlQXJncxIYCgVmaWxlcxgBIAMoCzIJLkZpbGVTdGF0Ih0KD0ZpbGVQcm9iZVJlc3VsdBIKCgJvaxgBIAMoCCI3Cg5GaWxlVXBsb2FkQXJncxIXCgRzdGF0GAEgASgLMgkuRmlsZVN0YXQSDAoEZmlsZRgCIAEoDCIeChBGaWxlVXBsb2FkUmVzdWx0EgoKAm9rGAEgASgIImMKDFByb3ZpZGVySW5mbxIMCgRuYW1lGAEgASgJEhAKCHBsYXRmb3JtGAIgASgJEhEKCXVzZXJhZ2VudBgDIAEoCRIgCgRwb29sGAQgASgLMhIuUHJvdmlkZXJSZXNvdXJjZXMiMAoRUHJvdmlkZXJSZXNvdXJjZXMSDAoEbm1heBgBIAEoDRINCgV0YXNrcxgCIAEoDTKKAgoIUHJvdmlkZXISMwoLRXhlY3V0ZVdhc2kSEC5FeGVjdXRlV2FzaUFyZ3MaEi5FeGVjdXRlV2FzaVJlc3VsdBIzCgtFeGVjdXRlV2FzbRIQLkV4ZWN1dGVXYXNtQXJncxoSLkV4ZWN1dGVXYXNtUmVzdWx0EjMKC0ZpbGVMaXN0aW5nEhAuRmlsZUxpc3RpbmdBcmdzGhIuRmlsZUxpc3RpbmdSZXN1bHQSLQoJRmlsZVByb2JlEg4uRmlsZVByb2JlQXJncxoQLkZpbGVQcm9iZVJlc3VsdBIwCgpGaWxlVXBsb2FkEg8uRmlsZVVwbG9hZEFyZ3MaES5GaWxlVXBsb2FkUmVzdWx0YghlZGl0aW9uc3DoBw", [file_google_protobuf_any, file_google_protobuf_timestamp]);

/**
 * Envelope contains one of [ Request | Response | Event ]. All of them contain
 * sequence counters but they count independently, so don't unify them up here.
 *
 * @generated from message Envelope
 */
export type Envelope = Message<"Envelope"> & {
  /**
   * @generated from oneof Envelope.message
   */
  message: {
    /**
     * @generated from field: Request request = 1;
     */
    value: Request;
    case: "request";
  } | {
    /**
     * @generated from field: Response response = 2;
     */
    value: Response;
    case: "response";
  } | {
    /**
     * @generated from field: Event event = 3;
     */
    value: Event;
    case: "event";
  } | { case: undefined; value?: undefined };
};

/**
 * JSON type for the message Envelope.
 */
export type EnvelopeJson = {
  /**
   * @generated from field: Request request = 1;
   */
  request?: RequestJson;

  /**
   * @generated from field: Response response = 2;
   */
  response?: ResponseJson;

  /**
   * @generated from field: Event event = 3;
   */
  event?: EventJson;
};

/**
 * Describes the message Envelope.
 * Use `create(EnvelopeSchema)` to create a new message.
 */
export const EnvelopeSchema: GenMessage<Envelope, EnvelopeJson> = /*@__PURE__*/
  messageDesc(file_messages, 0);

/**
 * Request is an RPC request with Any payload. The sequence number is used
 * in responses, so the caller can correctly route the pending response.
 *
 * @generated from message Request
 */
export type Request = Message<"Request"> & {
  /**
   * @generated from field: uint64 sequence = 1;
   */
  sequence: bigint;

  /**
   * TODO: timeout etc.
   *
   * @generated from field: google.protobuf.Any request = 3;
   */
  request?: Any;
};

/**
 * JSON type for the message Request.
 */
export type RequestJson = {
  /**
   * @generated from field: uint64 sequence = 1;
   */
  sequence?: string;

  /**
   * @generated from field: google.protobuf.Any request = 3;
   */
  request?: AnyJson;
};

/**
 * Describes the message Request.
 * Use `create(RequestSchema)` to create a new message.
 */
export const RequestSchema: GenMessage<Request, RequestJson> = /*@__PURE__*/
  messageDesc(file_messages, 1);

/**
 * Response is the reply to an RPC request with the same sequence number.
 * The presence of an error indicates that something went wrong with the call
 * in general (like a server "oops"). Otherwise, the called function may encode
 * its own error within the payload.
 *
 * @generated from message Response
 */
export type Response = Message<"Response"> & {
  /**
   * @generated from field: uint64 sequence = 1;
   */
  sequence: bigint;

  /**
   * nil => ok
   *
   * @generated from field: string error = 2;
   */
  error: string;

  /**
   * @generated from field: google.protobuf.Any response = 3;
   */
  response?: Any;
};

/**
 * JSON type for the message Response.
 */
export type ResponseJson = {
  /**
   * @generated from field: uint64 sequence = 1;
   */
  sequence?: string;

  /**
   * @generated from field: string error = 2;
   */
  error?: string;

  /**
   * @generated from field: google.protobuf.Any response = 3;
   */
  response?: AnyJson;
};

/**
 * Describes the message Response.
 * Use `create(ResponseSchema)` to create a new message.
 */
export const ResponseSchema: GenMessage<Response, ResponseJson> = /*@__PURE__*/
  messageDesc(file_messages, 2);

/**
 * Event is a simple informative message that expects no reply.
 *
 * @generated from message Event
 */
export type Event = Message<"Event"> & {
  /**
   * might be nil, if ordering is not important
   *
   * @generated from field: uint64 sequence = 1;
   */
  sequence: bigint;

  /**
   * @generated from field: google.protobuf.Any event = 3;
   */
  event?: Any;
};

/**
 * JSON type for the message Event.
 */
export type EventJson = {
  /**
   * @generated from field: uint64 sequence = 1;
   */
  sequence?: string;

  /**
   * @generated from field: google.protobuf.Any event = 3;
   */
  event?: AnyJson;
};

/**
 * Describes the message Event.
 * Use `create(EventSchema)` to create a new message.
 */
export const EventSchema: GenMessage<Event, EventJson> = /*@__PURE__*/
  messageDesc(file_messages, 3);

/**
 * Ping stub, if the transport does not provide them. WebSocket does have its
 * own mechanism. On WebTransport, you should use a separate stream to avoid re-
 * introducing head-of-line blocking with the other RPC requests; so Ping is
 * *not* in the Evelope oneof above.
 *
 * @generated from message Ping
 */
export type Ping = Message<"Ping"> & {
  /**
   * @generated from field: Ping.Direction direction = 1;
   */
  direction: Ping_Direction;

  /**
   * @generated from field: google.protobuf.Timestamp time = 2;
   */
  time?: Timestamp;
};

/**
 * JSON type for the message Ping.
 */
export type PingJson = {
  /**
   * @generated from field: Ping.Direction direction = 1;
   */
  direction?: Ping_DirectionJson;

  /**
   * @generated from field: google.protobuf.Timestamp time = 2;
   */
  time?: TimestampJson;
};

/**
 * Describes the message Ping.
 * Use `create(PingSchema)` to create a new message.
 */
export const PingSchema: GenMessage<Ping, PingJson> = /*@__PURE__*/
  messageDesc(file_messages, 4);

/**
 * @generated from enum Ping.Direction
 */
export enum Ping_Direction {
  /**
   * @generated from enum value: Ping = 0;
   */
  Ping = 0,

  /**
   * @generated from enum value: Pong = 1;
   */
  Pong = 1,
}

/**
 * JSON type for the enum Ping.Direction.
 */
export type Ping_DirectionJson = "Ping" | "Pong";

/**
 * Describes the enum Ping.Direction.
 */
export const Ping_DirectionSchema: GenEnum<Ping_Direction, Ping_DirectionJson> = /*@__PURE__*/
  enumDesc(file_messages, 4, 0);

/**
 * TaskMetadata contains some information about the originating task for logging
 *
 * @generated from message TaskMetadata
 */
export type TaskMetadata = Message<"TaskMetadata"> & {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * @generated from field: string client = 2;
   */
  client: string;

  /**
   * within a job with multiple tasks
   *
   * @generated from field: uint64 index = 3;
   */
  index: bigint;
};

/**
 * JSON type for the message TaskMetadata.
 */
export type TaskMetadataJson = {
  /**
   * @generated from field: string id = 1;
   */
  id?: string;

  /**
   * @generated from field: string client = 2;
   */
  client?: string;

  /**
   * @generated from field: uint64 index = 3;
   */
  index?: string;
};

/**
 * Describes the message TaskMetadata.
 * Use `create(TaskMetadataSchema)` to create a new message.
 */
export const TaskMetadataSchema: GenMessage<TaskMetadata, TaskMetadataJson> = /*@__PURE__*/
  messageDesc(file_messages, 5);

/**
 * Executable can be either a string reference or the raw binary itself
 *
 * @generated from message Executable
 */
export type Executable = Message<"Executable"> & {
  /**
   * @generated from oneof Executable.binary
   */
  binary: {
    /**
     * @generated from field: string reference = 1;
     */
    value: string;
    case: "reference";
  } | {
    /**
     * @generated from field: bytes raw = 2;
     */
    value: Uint8Array;
    case: "raw";
  } | { case: undefined; value?: undefined };
};

/**
 * JSON type for the message Executable.
 */
export type ExecutableJson = {
  /**
   * @generated from field: string reference = 1;
   */
  reference?: string;

  /**
   * @generated from field: bytes raw = 2;
   */
  raw?: string;
};

/**
 * Describes the message Executable.
 * Use `create(ExecutableSchema)` to create a new message.
 */
export const ExecutableSchema: GenMessage<Executable, ExecutableJson> = /*@__PURE__*/
  messageDesc(file_messages, 6);

/**
 * ExecuteWasi runs a webassembly/wasi binary on the Provider
 *
 * @generated from message ExecuteWasiArgs
 */
export type ExecuteWasiArgs = Message<"ExecuteWasiArgs"> & {
  /**
   * @generated from field: TaskMetadata task = 1;
   */
  task?: TaskMetadata;

  /**
   * @generated from field: Executable binary = 2;
   */
  binary?: Executable;

  /**
   * @generated from field: repeated string args = 3;
   */
  args: string[];

  /**
   * @generated from field: repeated string envs = 4;
   */
  envs: string[];

  /**
   * @generated from field: bytes stdin = 5;
   */
  stdin: Uint8Array;

  /**
   * TODO: replace with complete rootfs archive
   *
   * @generated from field: repeated string loadfs = 6;
   */
  loadfs: string[];
};

/**
 * JSON type for the message ExecuteWasiArgs.
 */
export type ExecuteWasiArgsJson = {
  /**
   * @generated from field: TaskMetadata task = 1;
   */
  task?: TaskMetadataJson;

  /**
   * @generated from field: Executable binary = 2;
   */
  binary?: ExecutableJson;

  /**
   * @generated from field: repeated string args = 3;
   */
  args?: string[];

  /**
   * @generated from field: repeated string envs = 4;
   */
  envs?: string[];

  /**
   * @generated from field: bytes stdin = 5;
   */
  stdin?: string;

  /**
   * @generated from field: repeated string loadfs = 6;
   */
  loadfs?: string[];
};

/**
 * Describes the message ExecuteWasiArgs.
 * Use `create(ExecuteWasiArgsSchema)` to create a new message.
 */
export const ExecuteWasiArgsSchema: GenMessage<ExecuteWasiArgs, ExecuteWasiArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 7);

/**
 * TODO
 *
 * @generated from message ExecuteWasiResult
 */
export type ExecuteWasiResult = Message<"ExecuteWasiResult"> & {
};

/**
 * JSON type for the message ExecuteWasiResult.
 */
export type ExecuteWasiResultJson = {
};

/**
 * Describes the message ExecuteWasiResult.
 * Use `create(ExecuteWasiResultSchema)` to create a new message.
 */
export const ExecuteWasiResultSchema: GenMessage<ExecuteWasiResult, ExecuteWasiResultJson> = /*@__PURE__*/
  messageDesc(file_messages, 8);

/**
 * ExecuteWasm runs a webassembly/plain binary on the Provider
 *
 * @generated from message ExecuteWasmArgs
 */
export type ExecuteWasmArgs = Message<"ExecuteWasmArgs"> & {
  /**
   * @generated from field: TaskMetadata task = 1;
   */
  task?: TaskMetadata;

  /**
   * @generated from field: Executable binary = 2;
   */
  binary?: Executable;

  /**
   * TODO: how to encode plain parameters?
   *
   * @generated from field: string method = 3;
   */
  method: string;
};

/**
 * JSON type for the message ExecuteWasmArgs.
 */
export type ExecuteWasmArgsJson = {
  /**
   * @generated from field: TaskMetadata task = 1;
   */
  task?: TaskMetadataJson;

  /**
   * @generated from field: Executable binary = 2;
   */
  binary?: ExecutableJson;

  /**
   * @generated from field: string method = 3;
   */
  method?: string;
};

/**
 * Describes the message ExecuteWasmArgs.
 * Use `create(ExecuteWasmArgsSchema)` to create a new message.
 */
export const ExecuteWasmArgsSchema: GenMessage<ExecuteWasmArgs, ExecuteWasmArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 9);

/**
 * TODO
 *
 * @generated from message ExecuteWasmResult
 */
export type ExecuteWasmResult = Message<"ExecuteWasmResult"> & {
};

/**
 * JSON type for the message ExecuteWasmResult.
 */
export type ExecuteWasmResultJson = {
};

/**
 * Describes the message ExecuteWasmResult.
 * Use `create(ExecuteWasmResultSchema)` to create a new message.
 */
export const ExecuteWasmResultSchema: GenMessage<ExecuteWasmResult, ExecuteWasmResultJson> = /*@__PURE__*/
  messageDesc(file_messages, 10);

/**
 * FileStat contains metadata about a file for identification in other messages
 *
 * @generated from message FileStat
 */
export type FileStat = Message<"FileStat"> & {
  /**
   * @generated from field: string filename = 1;
   */
  filename: string;

  /**
   * @generated from field: string contenttype = 2;
   */
  contenttype: string;

  /**
   * @generated from field: uint64 length = 3;
   */
  length: bigint;

  /**
   * @generated from field: uint64 epoch = 5;
   */
  epoch: bigint;

  /**
   * @generated from field: bytes hash = 4;
   */
  hash: Uint8Array;
};

/**
 * JSON type for the message FileStat.
 */
export type FileStatJson = {
  /**
   * @generated from field: string filename = 1;
   */
  filename?: string;

  /**
   * @generated from field: string contenttype = 2;
   */
  contenttype?: string;

  /**
   * @generated from field: uint64 length = 3;
   */
  length?: string;

  /**
   * @generated from field: uint64 epoch = 5;
   */
  epoch?: string;

  /**
   * @generated from field: bytes hash = 4;
   */
  hash?: string;
};

/**
 * Describes the message FileStat.
 * Use `create(FileStatSchema)` to create a new message.
 */
export const FileStatSchema: GenMessage<FileStat, FileStatJson> = /*@__PURE__*/
  messageDesc(file_messages, 11);

/**
 * FileListing asks for a listing of all available files on Provider
 *
 * empty
 *
 * @generated from message FileListingArgs
 */
export type FileListingArgs = Message<"FileListingArgs"> & {
};

/**
 * JSON type for the message FileListingArgs.
 */
export type FileListingArgsJson = {
};

/**
 * Describes the message FileListingArgs.
 * Use `create(FileListingArgsSchema)` to create a new message.
 */
export const FileListingArgsSchema: GenMessage<FileListingArgs, FileListingArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 12);

/**
 * @generated from message FileListingResult
 */
export type FileListingResult = Message<"FileListingResult"> & {
  /**
   * @generated from field: repeated FileStat files = 1;
   */
  files: FileStat[];
};

/**
 * JSON type for the message FileListingResult.
 */
export type FileListingResultJson = {
  /**
   * @generated from field: repeated FileStat files = 1;
   */
  files?: FileStatJson[];
};

/**
 * Describes the message FileListingResult.
 * Use `create(FileListingResultSchema)` to create a new message.
 */
export const FileListingResultSchema: GenMessage<FileListingResult, FileListingResultJson> = /*@__PURE__*/
  messageDesc(file_messages, 13);

/**
 * FileProbe checks if a certain file exists on provider
 *
 * @generated from message FileProbeArgs
 */
export type FileProbeArgs = Message<"FileProbeArgs"> & {
  /**
   * @generated from field: repeated FileStat files = 1;
   */
  files: FileStat[];
};

/**
 * JSON type for the message FileProbeArgs.
 */
export type FileProbeArgsJson = {
  /**
   * @generated from field: repeated FileStat files = 1;
   */
  files?: FileStatJson[];
};

/**
 * Describes the message FileProbeArgs.
 * Use `create(FileProbeArgsSchema)` to create a new message.
 */
export const FileProbeArgsSchema: GenMessage<FileProbeArgs, FileProbeArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 14);

/**
 * @generated from message FileProbeResult
 */
export type FileProbeResult = Message<"FileProbeResult"> & {
  /**
   * @generated from field: repeated bool ok = 1;
   */
  ok: boolean[];
};

/**
 * JSON type for the message FileProbeResult.
 */
export type FileProbeResultJson = {
  /**
   * @generated from field: repeated bool ok = 1;
   */
  ok?: boolean[];
};

/**
 * Describes the message FileProbeResult.
 * Use `create(FileProbeResultSchema)` to create a new message.
 */
export const FileProbeResultSchema: GenMessage<FileProbeResult, FileProbeResultJson> = /*@__PURE__*/
  messageDesc(file_messages, 15);

/**
 * FileUpload pushes a file to the Provider.
 * TODO: to be replaced with on-demand client-side fetch
 *
 * @generated from message FileUploadArgs
 */
export type FileUploadArgs = Message<"FileUploadArgs"> & {
  /**
   * @generated from field: FileStat stat = 1;
   */
  stat?: FileStat;

  /**
   * @generated from field: bytes file = 2;
   */
  file: Uint8Array;
};

/**
 * JSON type for the message FileUploadArgs.
 */
export type FileUploadArgsJson = {
  /**
   * @generated from field: FileStat stat = 1;
   */
  stat?: FileStatJson;

  /**
   * @generated from field: bytes file = 2;
   */
  file?: string;
};

/**
 * Describes the message FileUploadArgs.
 * Use `create(FileUploadArgsSchema)` to create a new message.
 */
export const FileUploadArgsSchema: GenMessage<FileUploadArgs, FileUploadArgsJson> = /*@__PURE__*/
  messageDesc(file_messages, 16);

/**
 * @generated from message FileUploadResult
 */
export type FileUploadResult = Message<"FileUploadResult"> & {
  /**
   * @generated from field: bool ok = 1;
   */
  ok: boolean;
};

/**
 * JSON type for the message FileUploadResult.
 */
export type FileUploadResultJson = {
  /**
   * @generated from field: bool ok = 1;
   */
  ok?: boolean;
};

/**
 * Describes the message FileUploadResult.
 * Use `create(FileUploadResultSchema)` to create a new message.
 */
export const FileUploadResultSchema: GenMessage<FileUploadResult, FileUploadResultJson> = /*@__PURE__*/
  messageDesc(file_messages, 17);

/**
 * ProviderInfo is sent once at the beginning to identify the Provider
 *
 * @generated from message ProviderInfo
 */
export type ProviderInfo = Message<"ProviderInfo"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: string platform = 2;
   */
  platform: string;

  /**
   * @generated from field: string useragent = 3;
   */
  useragent: string;

  /**
   * @generated from field: ProviderResources pool = 4;
   */
  pool?: ProviderResources;
};

/**
 * JSON type for the message ProviderInfo.
 */
export type ProviderInfoJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * @generated from field: string platform = 2;
   */
  platform?: string;

  /**
   * @generated from field: string useragent = 3;
   */
  useragent?: string;

  /**
   * @generated from field: ProviderResources pool = 4;
   */
  pool?: ProviderResourcesJson;
};

/**
 * Describes the message ProviderInfo.
 * Use `create(ProviderInfoSchema)` to create a new message.
 */
export const ProviderInfoSchema: GenMessage<ProviderInfo, ProviderInfoJson> = /*@__PURE__*/
  messageDesc(file_messages, 18);

/**
 * ProviderResources is information about the available resources in Worker pool
 *
 * @generated from message ProviderResources
 */
export type ProviderResources = Message<"ProviderResources"> & {
  /**
   * maximum available
   *
   * @generated from field: uint32 nmax = 1;
   */
  nmax: number;

  /**
   * currently active
   *
   * @generated from field: uint32 tasks = 2;
   */
  tasks: number;
};

/**
 * JSON type for the message ProviderResources.
 */
export type ProviderResourcesJson = {
  /**
   * @generated from field: uint32 nmax = 1;
   */
  nmax?: number;

  /**
   * @generated from field: uint32 tasks = 2;
   */
  tasks?: number;
};

/**
 * Describes the message ProviderResources.
 * Use `create(ProviderResourcesSchema)` to create a new message.
 */
export const ProviderResourcesSchema: GenMessage<ProviderResources, ProviderResourcesJson> = /*@__PURE__*/
  messageDesc(file_messages, 19);

/**
 * we're not using gRPC but we can codify the expected message types anyway
 *
 * @generated from service Provider
 */
export const Provider: GenService<{
  /**
   * execute
   *
   * @generated from rpc Provider.ExecuteWasi
   */
  executeWasi: {
    methodKind: "unary";
    input: typeof ExecuteWasiArgsSchema;
    output: typeof ExecuteWasiResultSchema;
  },
  /**
   * @generated from rpc Provider.ExecuteWasm
   */
  executeWasm: {
    methodKind: "unary";
    input: typeof ExecuteWasmArgsSchema;
    output: typeof ExecuteWasmResultSchema;
  },
  /**
   * filesystem
   *
   * @generated from rpc Provider.FileListing
   */
  fileListing: {
    methodKind: "unary";
    input: typeof FileListingArgsSchema;
    output: typeof FileListingResultSchema;
  },
  /**
   * @generated from rpc Provider.FileProbe
   */
  fileProbe: {
    methodKind: "unary";
    input: typeof FileProbeArgsSchema;
    output: typeof FileProbeResultSchema;
  },
  /**
   * @generated from rpc Provider.FileUpload
   */
  fileUpload: {
    methodKind: "unary";
    input: typeof FileUploadArgsSchema;
    output: typeof FileUploadResultSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_messages, 0);

